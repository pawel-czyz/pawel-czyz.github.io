{
  "hash": "287c6889f2c9baef3fa76dbb9b61de3f",
  "result": {
    "markdown": "---\ntitle: Understanding board games with Monte Carlo simulations\ndescription: We look at several simple situations occurring in board games and analyse them with Monte Carlo simulations.\nauthor: Paweł Czyż\ndate: 7/9/2023\ncategories:\n  - Monte Carlo\nexecute:\n  freeze: true\nformat:\n  html:\n    code-fold: true\n---\n\nI like playing board games, but I never remember the probabilities of different interesting events. Let's code a very simple [Monte Carlo simulation](https://en.wikipedia.org/wiki/Monte_Carlo_method) to evaluate probabilities used in them, so I can revisit to this website and use it to (maybe eventually) win.\n\n## Fight or flight?\n\nIn the rare days when I find time to play [Runebound](https://boardgamegeek.com/boardgame/21523/runebound-second-edition), I find myself in situations fighting monsters and trying to decide whether I should try to fight them or escape. I know a monster's strength (high), I know my strength (low), but I don't know how likely it is that the difference can be compensated by throwing two ten-sided dice. \n\nLet's estimate the chances of getting *at least* $X$ points due to the dice throw.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nn_simulations: int = 100_000\ndice: int = 10\n\nrng = np.random.default_rng(42)\noccurrences = np.zeros(2 * dice + 1, dtype=float)\n\nthrows = rng.integers(1, dice, endpoint=True, size=(n_simulations, 2))\ntotal = throws.sum(axis=1)\n\nfor t in total:\n    occurrences[:t+1] += 1\n\noccurrences /= n_simulations\n\nfor i, p in enumerate(occurrences):\n    if i < 1:\n        continue\n    print(f\"{i}: {100*p:.1f}%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1: 100.0%\n2: 100.0%\n3: 99.0%\n4: 97.0%\n5: 94.0%\n6: 90.1%\n7: 85.2%\n8: 79.2%\n9: 72.2%\n10: 64.1%\n11: 55.1%\n12: 45.2%\n13: 36.0%\n14: 28.0%\n15: 21.1%\n16: 15.1%\n17: 10.0%\n18: 6.0%\n19: 3.0%\n20: 1.0%\n```\n:::\n:::\n\n\nIn this case it's also very easy to actually calculate the probabilities without Monte Carlo simulation:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nprobabilities = np.zeros(2*dice + 1, dtype=float)\n\nfor result1 in range(1, dice + 1):\n    for result2 in range(1, dice + 1):\n        total = result1 + result2\n        probabilities[:total + 1] += 1/dice**2\n\nfor i, p in enumerate(occurrences):\n    if i < 1:\n        continue\n    print(f\"{i}: {100*p:.1f}%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1: 100.0%\n2: 100.0%\n3: 99.0%\n4: 97.0%\n5: 94.0%\n6: 90.1%\n7: 85.2%\n8: 79.2%\n9: 72.2%\n10: 64.1%\n11: 55.1%\n12: 45.2%\n13: 36.0%\n14: 28.0%\n15: 21.1%\n16: 15.1%\n17: 10.0%\n18: 6.0%\n19: 3.0%\n20: 1.0%\n```\n:::\n:::\n\n\nThe exact solution requires $O(K^2)$ operations, where one uses two dice with $K$ sides[^1]. For a larger number of dice this solution may not be as tractable, so Monte Carlo approximations may shine.\n\n[^1]: The implemented solution works in $O(K^3)$ due to the `probabilities[:total + 1]` operation. If the performance did really matter here, we could store the occurrences and then calculate cumulative sums only once in the end.\n\n## Where should my cheese be?\n\nIn [Cashflow](https://boardgamegeek.com/boardgame/6552/cashflow-101) one way to win the end-game is to quickly get to the tile with a cheese-shaped token. As this token can be placed in advance, I was wondering what the optimal location of it should be.\n\nIf I put the token on the first tile, I need to throw *exactly one* in my first throw or I will need to travel across the whole board to close the loop and have another chance (or try to win the game in another way).\n\nLet's use Monte Carlo simulation to estimate where I should put the token so I can win in at most five moves:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np \n\nN_SIMULATIONS: int = 100_000\nN_THROWS: int = 5\nDICE: int = 6  # Number of sides on the dice\nrng = np.random.default_rng(101)\n\nvisitations = np.zeros(N_THROWS * DICE + 1)\n\nfor simulation in range(N_SIMULATIONS):\n    position = 0\n    for throw_index in range(N_THROWS):\n        result = rng.integers(1, DICE, endpoint=True)\n        position += result\n        visitations[position] += 1\n\nfor i in range(N_THROWS * DICE + 1):\n    percentage = 100 * visitations[i] / N_SIMULATIONS\n    print(f\"{i}: {percentage:.1f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0: 0.0\n1: 16.5\n2: 19.3\n3: 22.8\n4: 26.4\n5: 30.8\n6: 36.2\n7: 25.2\n8: 26.8\n9: 28.1\n10: 28.6\n11: 28.4\n12: 27.9\n13: 25.8\n14: 25.1\n15: 24.0\n16: 21.8\n17: 19.6\n18: 16.5\n19: 13.9\n20: 11.2\n21: 8.5\n22: 6.2\n23: 4.3\n24: 2.7\n25: 1.6\n26: 0.9\n27: 0.5\n28: 0.2\n29: 0.1\n30: 0.0\n```\n:::\n:::\n\n\nAgain, we could do this in the exact fashion --- for example, for 30 we know that the probability is exactly $6^{-5}\\approx 0.013\\%$, but it's quite clear that the sixth tile gives decent chances of winning in the first few moves.\n\n",
    "supporting": [
      "board-games-monte-carlo_files"
    ],
    "filters": [],
    "includes": {}
  }
}
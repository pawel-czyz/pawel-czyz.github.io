<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Paweł Czyż">
<meta name="dcterms.date" content="2024-09-01">
<meta name="description" content="Markov chain got stuck in a single mode? Parallel tempering comes to help.">

<title>Paweł Czyż - Non-reversible parallel tempering</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-PZ6W6SFE14"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-PZ6W6SFE14', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Paweł Czyż</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../publications.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#parallel-tempering-as-originally-designed" id="toc-parallel-tempering-as-originally-designed" class="nav-link active" data-scroll-target="#parallel-tempering-as-originally-designed">Parallel tempering as originally designed</a>
  <ul class="collapse">
  <li><a href="#jax-implementation" id="toc-jax-implementation" class="nav-link" data-scroll-target="#jax-implementation">JAX implementation</a></li>
  <li><a href="#what-if" id="toc-what-if" class="nav-link" data-scroll-target="#what-if">What if?</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  <li><a href="#non-reversible-parallel-tempering" id="toc-non-reversible-parallel-tempering" class="nav-link" data-scroll-target="#non-reversible-parallel-tempering">Non-reversible parallel tempering</a>
  <ul class="collapse">
  <li><a href="#jax-implementation-of-deo" id="toc-jax-implementation-of-deo" class="nav-link" data-scroll-target="#jax-implementation-of-deo">JAX implementation of DEO</a></li>
  <li><a href="#why-non-reversible-parallel-tempering" id="toc-why-non-reversible-parallel-tempering" class="nav-link" data-scroll-target="#why-non-reversible-parallel-tempering">Why non-reversible parallel tempering?</a></li>
  <li><a href="#annealing-schedule-optimisation" id="toc-annealing-schedule-optimisation" class="nav-link" data-scroll-target="#annealing-schedule-optimisation">Annealing schedule optimisation</a></li>
  <li><a href="#summary-1" id="toc-summary-1" class="nav-link" data-scroll-target="#summary-1">Summary</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Non-reversible parallel tempering</h1>
</div>

<div>
  <div class="description">
    Markov chain got stuck in a single mode? Parallel tempering comes to help.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Paweł Czyż </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 1, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>I have revived my interest in <a href="../posts/distinct-ising-models.html">Ising models</a>, which can be now trained using <a href="../posts/discrete-intractable-likelihood.html">discrete Fisher divergence</a>. However, once the model is trained, I would like to generate synthetic samples and evaluate the quality of the fit.</p>
<p>The standard solution for sampling from such distributions is our usual suspect, Markov chain Monte Carlo (MCMC). However, MCMC can get “trapped” in a single mode of the distribution and never escape it within the (finite) simulation time. Ising models are somewhat hard to visualise, so let’s focus on some one-dimensional problem and the simple Metropolis algorithm with Gaussian random walk proposals, namely <span class="math inline">\(q(x'\mid x) = \mathcal N\!\left(x' \mid x, \sigma^2\right)\)</span>.</p>
<p>We can use MCMC to obtain samples for the following problems:</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.random <span class="im">as</span> jrandom</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jaxtyping <span class="im">import</span> Float, Int, Array</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpyro</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpyro.distributions <span class="im">as</span> dist</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">"dark_background"</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Any</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> OrderedDict</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>RandomKey <span class="op">=</span> jax.Array</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>Kernel <span class="op">=</span> <span class="bu">callable</span>  <span class="co"># kernel(key, x) -&gt; new_x</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>KernelParam <span class="op">=</span> Any</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> JAXRNG:</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""JAX stateful random number generator.</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">      key = jax.random.PRNGKey(5)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co">      rng = JAXRNG(key)</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co">      a = jax.random.bernoulli(rng.key, shape=(10,))</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="co">      b = jax.random.bernoulli(rng.key, shape=(10,))</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, key: RandomKey) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co">            key: initialization key</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._key <span class="op">=</span> key</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> key(<span class="va">self</span>) <span class="op">-&gt;</span> RandomKey:</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Generates a new key."""</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        key, subkey <span class="op">=</span> jax.random.split(<span class="va">self</span>._key)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._key <span class="op">=</span> key</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> subkey</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Used by the repr() method."""</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ss">f"</span><span class="sc">{</span><span class="bu">type</span>(<span class="va">self</span>)<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss">(key=</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>_key<span class="sc">}</span><span class="ss">)"</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Used by the str() method."""</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">repr</span>(<span class="va">self</span>)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mcmc_sampling_loop(</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>  key: RandomKey,</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>  x0: Float[Array, <span class="st">" *dim"</span>],</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>  kernel: Kernel,</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>  n_samples: <span class="bu">int</span>,</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>  warmup: <span class="bu">int</span> <span class="op">=</span> <span class="dv">2_000</span>,</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">"n_samples *dim"</span>]:</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Markov chain Monte Carlo sampling loop."""</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> f(x, subkey):</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    x_new <span class="op">=</span> kernel(subkey, x)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x_new, x_new</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>  key_warmup, key_sampling <span class="op">=</span> jrandom.split(key)</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Run warm-up: update the starting point, but do not collect samples:</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>  x0, _ <span class="op">=</span> jax.lax.scan(f, x0, jrandom.split(key_warmup, warmup))</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Collect the samples:</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>  _, samples <span class="op">=</span> jax.lax.scan(f, x0, jrandom.split(key_sampling, n_samples))</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> samples</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_exact(</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>  key: RandomKey,</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>  distributions: OrderedDict,</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>  n_samples: <span class="bu">int</span>,</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">"n_distributions n_samples"</span>]:</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Samples from the ground-truth distributions using (exact) ancestral sampling in NumPyro.</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a><span class="co">  </span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="co">  Args:</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a><span class="co">    key: JAX random key</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="co">    distributions: an ordered dictionary mapping names to distribution factories. For example, `OrderedDict({"name": factory})`, where `factory()` returns a NumPyro distribution.</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a><span class="co">    n_samples: number of samples to collect  </span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>  xs_all <span class="op">=</span> np.empty((<span class="bu">len</span>(distributions), n_samples))</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> idx, (_, dist_factory) <span class="kw">in</span> <span class="bu">enumerate</span>(distributions.items()):</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>    key, subkey <span class="op">=</span> jrandom.split(key)</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    distrib <span class="op">=</span> dist_factory()</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">=</span> distrib.sample(subkey, sample_shape<span class="op">=</span>(n_samples,))</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>    xs_all[idx, :] <span class="op">=</span> np.array(xs)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> xs_all</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_multirun(</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>  key: RandomKey,</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>  sampling_fn,</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>  distributions: OrderedDict,</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>  params: <span class="bu">list</span>,</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">"params distributions *samples"</span>]:</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""This function applies a sampling function over all distributions and parameters.</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="co">  Args:</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a><span class="co">    sampling_fn: function used to provide samples. It has the signature</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="co">        sampling_fn(key, log_prob, param) -&gt; Float[Array, " *samples"]</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a><span class="co">      where "*samples" encodes all the dimension of the sample</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>  all_samples <span class="op">=</span> []</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> param <span class="kw">in</span> params:</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    samples_param <span class="op">=</span> []</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _, dist_factory <span class="kw">in</span> distributions.items():</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define log-PDF</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> log_p(x):</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        distribution <span class="op">=</span> dist_factory()</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> distribution.log_prob(x)</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>      key, subkey <span class="op">=</span> jrandom.split(key)</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>      samples <span class="op">=</span> np.array(sampling_fn(key, log_p, param))</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Append the samples</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>      samples_param.append(samples)</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now add the row</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>    all_samples.append(np.array(samples_param))</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.array(all_samples)</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mcmc_multirun(</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>  key: RandomKey,</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>  kernel_generator,</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>  distributions: OrderedDict,</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>  params: <span class="bu">list</span>[KernelParam],</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>  n_samples: <span class="bu">int</span>,</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>  warmup: <span class="bu">int</span>,</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>  x0: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">"params distributions n_samples"</span>]:</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""A high-level function running an array of MCMC samplers</span></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a><span class="co">  over different distributions and parameter settings.</span></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> sampling_fn(key, log_prob, param):</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> kernel_generator(log_prob, param)</span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mcmc_sampling_loop(</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>      key<span class="op">=</span>key, x0<span class="op">=</span>jnp.asarray(x0), kernel<span class="op">=</span>kernel, n_samples<span class="op">=</span>n_samples, warmup<span class="op">=</span>warmup</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> make_multirun(</span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>    key<span class="op">=</span>key, sampling_fn<span class="op">=</span>sampling_fn, distributions<span class="op">=</span>distributions, params<span class="op">=</span>params</span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>/home/pawel/micromamba/envs/data-science/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html
  from .autonotebook import tqdm as notebook_tqdm</code></pre>
</div>
</div>
<div class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_multipanel_figure(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  plotting_fn,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  distributions: OrderedDict,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  params: <span class="bu">list</span>[KernelParam],</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  samples_exact: Float[Array, <span class="st">"distributions n_samples_exact"</span>] <span class="op">|</span> <span class="va">None</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  samples_mcmc: Float[Array, <span class="st">"params distributions n_samples_mcmc"</span>],</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  n_spines: <span class="bu">int</span> <span class="op">=</span> <span class="dv">1</span>,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  dpi<span class="op">=</span><span class="dv">350</span>,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  param_name <span class="op">=</span> <span class="st">""</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _param_to_str(p):</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(p, <span class="bu">float</span>):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="ss">f"</span><span class="sc">{</span>p<span class="sc">:.1f}</span><span class="ss">"</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="bu">str</span>(p)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">len</span>(params),</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">len</span>(distributions),</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    sharex<span class="op">=</span>sharex,</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    dpi<span class="op">=</span>dpi,</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> param_idx, param_value <span class="kw">in</span> <span class="bu">enumerate</span>(params):</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> param_name <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>      axs[param_idx, <span class="dv">0</span>].set_ylabel(_param_to_str(param_value))</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>      axs[param_idx, <span class="dv">0</span>].set_ylabel(<span class="ss">f"</span><span class="sc">{</span>param_name<span class="sc">}</span><span class="ss">=</span><span class="sc">{</span>_param_to_str(param_value)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dist_idx, (dist_name, _) <span class="kw">in</span> <span class="bu">enumerate</span>(DISTRIBUTIONS.items()):</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>      ax <span class="op">=</span> axs[param_idx, dist_idx]</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> param_idx <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        ax.set_title(dist_name)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> samples_exact <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        se <span class="op">=</span> <span class="va">None</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>:</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        se <span class="op">=</span> samples_exact[dist_idx]</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>      plotting_fn(</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        ax,</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        se,</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        samples_mcmc[param_idx, dist_idx]</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> ax <span class="kw">in</span> axs.ravel():</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_spines <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>      ax.spines[[<span class="st">"top"</span>, <span class="st">"left"</span>, <span class="st">"right"</span>]].set_visible(<span class="va">False</span>)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>      ax.set_yticks([])</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n_spines <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>      ax.spines[[<span class="st">"top"</span>, <span class="st">"right"</span>]].set_visible(<span class="va">False</span>)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>  fig.tight_layout()</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_hist_panel_function(</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>  ax: plt.Axes,</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>  exact_samples: Float[Array, <span class="st">" n_samples_exact"</span>],</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>  mcmc_samples: Float[Array, <span class="st">" n_samples_mcmc"</span>],</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>  bins: <span class="bu">int</span> <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>  ax.hist(exact_samples, density<span class="op">=</span><span class="va">True</span>, bins<span class="op">=</span>bins, histtype<span class="op">=</span><span class="st">"step"</span>, color<span class="op">=</span><span class="st">"white"</span>)</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>  ax.hist(mcmc_samples, density<span class="op">=</span><span class="va">True</span>, bins<span class="op">=</span>bins, histtype<span class="op">=</span><span class="st">"stepfilled"</span>, color<span class="op">=</span><span class="st">"C3"</span>, alpha<span class="op">=</span><span class="fl">0.4</span>)</span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_trace_panel_function(</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>  ax: plt.Axes,</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>  exact_samples: Float[Array, <span class="st">" n_samples_exact"</span>],</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>  mcmc_samples: Float[Array, <span class="st">" n_samples_mcmc"</span>],</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>  ax.plot(mcmc_samples, color<span class="op">=</span><span class="st">"C3"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mixture2_dist() <span class="op">-&gt;</span> dist.Distribution:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  p <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  probs <span class="op">=</span> jnp.asarray([p, <span class="fl">1.0</span> <span class="op">-</span> p])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  sep <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  mus <span class="op">=</span> jnp.asarray([<span class="op">-</span>sep, sep], dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  mixing <span class="op">=</span> dist.Categorical(probs<span class="op">=</span>probs)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> dist.MixtureSameFamily(</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    mixing_distribution<span class="op">=</span>mixing,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    component_distribution<span class="op">=</span>dist.Normal(mus, <span class="fl">1.0</span>),</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mixture3_dist() <span class="op">-&gt;</span> dist.Distribution:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  probs <span class="op">=</span> jnp.asarray([<span class="fl">0.15</span>, <span class="fl">0.3</span>, <span class="fl">0.55</span>])</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  sep <span class="op">=</span> <span class="dv">35</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  mus <span class="op">=</span> jnp.asarray([<span class="op">-</span>sep, <span class="fl">0.</span>, sep])</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  mixing <span class="op">=</span> dist.Categorical(probs<span class="op">=</span>probs)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> dist.MixtureSameFamily(</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    mixing_distribution<span class="op">=</span>mixing,</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    component_distribution<span class="op">=</span>dist.Normal(mus, <span class="fl">1.0</span>),</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>RNG_JAX <span class="op">=</span> JAXRNG(jrandom.PRNGKey(<span class="dv">42</span>))</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>RNG_NPY <span class="op">=</span> np.random.default_rng(<span class="dv">101</span>)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>DISTRIBUTIONS <span class="op">=</span> {</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Normal"</span>: <span class="kw">lambda</span>: dist.Normal(<span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Mixture (2 comp.)"</span>: mixture2_dist,</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Mixture (3 comp.)"</span>: mixture3_dist,</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>SAMPLES_EXACT <span class="op">=</span> sample_exact(</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">3_000</span>,</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_kernel(</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>  logp_fn,</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>  sigma: <span class="bu">float</span>,</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Kernel:</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Generates a random-walk kernel.</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a><span class="co">  Args:</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="co">    logp_fn: function mapping a point to log-density</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="co">    sigma: scale of the random walk</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> kernel(</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    key: RandomKey,</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    x: Float[Array, <span class="st">" dim"</span>],</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>  ) <span class="op">-&gt;</span> Float[Array, <span class="st">" dim"</span>]:</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>    key1, key2 <span class="op">=</span> jrandom.split(key)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate a proposal</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>    x_ <span class="op">=</span> x <span class="op">+</span> sigma <span class="op">*</span> jrandom.normal(key1, shape<span class="op">=</span>x.shape)</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Evaluate the acceptance ratio</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>    log_p1 <span class="op">=</span> logp_fn(x)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    log_p2 <span class="op">=</span> logp_fn(x_)</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> jnp.exp(log_p2 <span class="op">-</span> log_p1)</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Decide whether to accept the proposal</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> jrandom.uniform(key2)</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jax.lax.select(u <span class="op">&lt;=</span> alpha, x_, x)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> kernel</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>SIGMAS <span class="op">=</span> [<span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">100</span>]</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_histograms(</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>  samples_exact,</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>  samples_mcmc,</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>  params,</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>  param_name,</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> make_multipanel_figure(</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>    plotting_fn<span class="op">=</span>plot_hist_panel_function,</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>    distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>    params<span class="op">=</span>params,</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>    samples_exact<span class="op">=</span>samples_exact,</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>    samples_mcmc<span class="op">=</span>samples_mcmc,</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>    n_spines<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>    param_name<span class="op">=</span>param_name,</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_traces(</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>  samples_mcmc,</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>  params,</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>  param_name,</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> make_multipanel_figure(</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>    plotting_fn<span class="op">=</span>plot_trace_panel_function,</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>    distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>    params<span class="op">=</span>params,</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>    samples_exact<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>    samples_mcmc<span class="op">=</span>samples_mcmc,</span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>    n_spines<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>    param_name<span class="op">=</span>param_name,</span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>_samples_mcmc <span class="op">=</span> mcmc_multirun(</span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>  kernel_generator<span class="op">=</span>generate_kernel,</span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a>  params<span class="op">=</span>SIGMAS,</span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">8_000</span>,</span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">5_000</span>,</span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a>  x0<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_mcmc, params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>An NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-4-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Some problems are already visible, but let’s take a look at the trace plots, tracking how the parameter has changed over time:</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_mcmc, params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-5-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>It turns out that:</p>
<ol type="1">
<li>Too small <span class="math inline">\(\sigma\)</span> results in large autocorrelation, making the effective sample size limited.</li>
<li>Medium <span class="math inline">\(\sigma\)</span> can explore a single mode effectively. However, they cannot travel reasonably often switch between the modes and attribute wrong posterior probabilities to them.</li>
<li>Large <span class="math inline">\(\sigma\)</span> allow one to switch between the modes quite often. However, for the simplest unimodal problem they suffer from low acceptance rate: many proposals are rejected.</li>
</ol>
<p>Perfectly, we would use a sampling scheme allowing for both efficient local exploration and frequent jumps between the modes. There are different reasonable strategies:</p>
<ol type="1">
<li>We could devise a better kernel by using e.g., compositions or mixtures of kernels with different <span class="math inline">\(\sigma\)</span>. Or use a more sophisticated strategy of combining kernels, such as <a href="https://www.jstor.org/stable/2673700">delayed rejection of P.J. Green and A. Mira (2001)</a>.</li>
<li>When working with continuous distributions defined on Euclidean spaces (which is the case here, but not for sampling from the Ising model), we could consider novel diffusion-based techniques such as the ones proposed by <a href="https://openreview.net/forum?id=kIPEyMSdFV">X. Huang et al.&nbsp;(2024)</a> or <a href="https://arxiv.org/abs/2402.10758">L. Grenioux et al.&nbsp;(2024)</a>.</li>
<li>Again in Euclidean spaces, memorise the modes and use a combination of local and jump moves, such as in <a href="https://arxiv.org/abs/1812.02609">E. Pompe et al.&nbsp;(2018)</a> or connect the modes via <a href="https://arxiv.org/abs/1306.0063">wormhole Hamiltonian Monte Carlo of S. Lan et al.&nbsp;(2013)</a>.</li>
<li>Use sequential Monte Carlo (SMC) samplers, as in the <a href="https://blackjax-devs.github.io/sampling-book/algorithms/TemperedSMC.html">BlackJAX sampling book</a> or <a href="https://youtu.be/mOA_IKyWdkg?feature=shared">this talk from Nicholas Chopin</a>. SMC samplers can be used on any space, provided that one has efficient locally-exploring kernels.</li>
<li>Another solution (historically existing before the SMC samplers) is to use <em>parallel tempering</em>, which dates back to <a href="https://www.stat.umn.edu/geyer/f05/8931/c.pdf">a 1991 paper of Charles Geyer</a>, then termed <span class="math inline">\((MC)^3\)</span>, i.e., Metropolis-coupled Markov chain Monte Carlo.</li>
</ol>
<p>Today we focus on the last method and look at a new variant of it.</p>
<section id="parallel-tempering-as-originally-designed" class="level2">
<h2 class="anchored" data-anchor-id="parallel-tempering-as-originally-designed">Parallel tempering as originally designed</h2>
<p>Consider a space <span class="math inline">\(\mathcal X\)</span> with a probability distribution of interest <span class="math inline">\(p\)</span> (by abuse of notation we write <span class="math inline">\(p\)</span> both for the probability distribution and for its density with respect to some convenient measure on <span class="math inline">\(\mathcal X\)</span>). We have a Markov kernel <span class="math inline">\(K\)</span> allowing us to explore <span class="math inline">\(\mathcal X\)</span> locally, but which has a trouble to pass through low-density regions separating distinct modes.</p>
<p>This issue can be addressed by extending the original space <span class="math inline">\(\mathcal X\)</span> to a larger space <span class="math inline">\(\mathcal X^{N+1} = \mathcal X \times \cdots \times \mathcal X\)</span> and targeting a product distribution <span class="math inline">\(\mathbf{p}(\mathbf x) = p_0(x_0)\cdots p_{N-1}(x_{N-1}) p_{N}(x_N)\)</span>, where <span class="math inline">\(p_N = p\)</span> is the original distribution of interest and <span class="math inline">\(p_0, \dotsc, p_{N-1}\)</span> are auxiliary distributions, designed to be easier to sample from. The main idea is that <span class="math inline">\(p_0\)</span> should be chosen so that it is known to be easy to sample (e.g., i.i.d. samples are easy to generate) and the consecutive distributions, <span class="math inline">\(p_{i}\)</span> and <span class="math inline">\(p_{i+1}\)</span>, should be closely related: the separate modes of <span class="math inline">\(p = p_N\)</span> can be then “connected” by going through <span class="math inline">\(p_{N-1}, p_{N-2}, \dotsc\)</span> to <span class="math inline">\(p_0\)</span>, which is then to sample from, and back.</p>
<p>For example, a typical choice for a sequence <span class="math inline">\(p_0, \dotsc, p_N=p\)</span> is to use an annealing schedule <span class="math inline">\(0 = \beta_0 &lt; \beta_1 &lt; \dotsc &lt; \beta_N = 1\)</span> and employ the following distribution: <span class="math display">\[
  p_n(x) = \frac{1}{\mathcal Z(\beta_n)} \left(\frac{p(x)}{p_0(x)}\right)^{\beta_n} p_0(x) = \frac{1}{\mathcal Z(\beta_n)} p(x)^{\beta_n} p_0(x)^{1-\beta_n}
\]</span></p>
<p>Similarly as in SMC samplers, the schedule does matter a lot, controlling how much consecutive distributions are related. However, there is an important difference between SMC samplers and parallel tempering: they are orthogonal to each other, in the sense that parallel tempering at any single time keeps the states at <em>across all the temperatures</em>, while SMC samplers always have all the particles at the same temperature, which then rises over time. (I think this observation was made by Nicholas Chopin in one of his lecture, although I can’t find the exact reference. Many apologies for misquoting or misattributing this statement)</p>
<p>A Markov chain is now defined on <span class="math inline">\(\mathcal X^{N+1}\)</span>, with a state <span class="math inline">\(\mathbf{x} = (x_0, \dotsc, x_N)\)</span>. We consider two transitions:</p>
<ol type="1">
<li>Applying Markov kernels <span class="math inline">\(K_n\)</span> to entries <span class="math inline">\(x_i\)</span>, targeting distributions <span class="math inline">\(p_i\)</span>, so that we do local exploration.</li>
<li>Swapping entries <span class="math inline">\(x_{i}\)</span> with <span class="math inline">\(x_{i+1}\)</span>, so that we can eventually pass from <span class="math inline">\(x_N\)</span> (which is targeting <span class="math inline">\(\pi\)</span>) to <span class="math inline">\(x_0\)</span> (which is easy to explore) and back.</li>
</ol>
<p>Note that if the second kind of moves were not allowed, we would have just <span class="math inline">\(N+1\)</span> independent Markov chains (each defined on the space <span class="math inline">\(\mathcal X\)</span>) and targeting the <span class="math inline">\(\mathbf{p}\)</span> distribution “individually”: the first chain would be efficient (exploring <span class="math inline">\(p_0\)</span>) and the last one would mix very, very slow. As the chains are coupled, they are not individually Markov anymore and they travel between different tempered distributions (hopefully eventually reaching the same distribution). We can use them then to extract samples just from the <span class="math inline">\(p=p_N\)</span> distribution.</p>
<p>To ensure that the Markov chain on <span class="math inline">\(\mathcal X^{N+1}\)</span> explores <span class="math inline">\(\mathbf{p}\)</span> properly, <a href="https://www.stat.umn.edu/geyer/f05/8931/c.pdf">Charles Geyer proposed</a> to swap components <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> according to a Metropolis update. If <span class="math inline">\(\mathbf{x}\)</span> is the current state and <span class="math inline">\(\mathbf{x}'\)</span> is the state with entries <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> swapped, the Metropolis ratio is given by <span class="math display">\[
  r(i, j) = \frac{ \mathbf{p}(\mathbf x')}{ \mathbf{p}(\mathbf x)} = \frac{ p_i(x_j) p_j(x_i)}{ p_i(x_i) p_j(x_j)}.
\]</span></p>
<p>Typically, only adjacent indices are swapped, as for <span class="math inline">\(i\)</span> very distant from <span class="math inline">\(j\)</span> we expect that <span class="math inline">\(r\)</span> would close to zero. It is also informative to write this ratio in terms of the target and the reference distributions. As <span class="math inline">\(\log p_n(x) = \beta_n \log p(x) + (1-\beta_n) \log p_0(x) - \log \mathcal Z(\beta_n)\)</span>, we have <span class="math display">\[\begin{align*}
\log r &amp;= \beta_i (\log p(x_j) - \log p(x_i)) + (1-\beta_i) (\log p_0(x_j) - \log p_0(x_i)) \\
&amp;+ \beta_j( \log p(x_i) - \log p(x_j) ) + (1-\beta_j)( \log p_0(x_i) - \log p_0(x_j) ) \\
&amp;= -(\beta_i - \beta_j) \left( \log \frac{p(x_i)}{p_0(x_i)} - \log \frac{p(x_j)}{p_0(x_j)} \right)  
\end{align*}
\]</span></p>
<p>This is a very convenient formula if <span class="math inline">\(p_0\)</span> corresponds to the prior distribution and <span class="math inline">\(p\)</span> is the posterior distribution, as their ratio is then simply the likelihood<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>This is enough theory for now – let’s implement parallel tempering in JAX.</p>
<section id="jax-implementation" class="level3">
<h3 class="anchored" data-anchor-id="jax-implementation">JAX implementation</h3>
<p>We need to make some design choices. We keep the state <span class="math inline">\(\mathbf{x} = (x_0, \dotsc, x_N)\)</span> as a matrix <span class="math inline">\((N+1)\times (\mathrm{dim}\, \mathcal X)\)</span>. As we have access to two log-probability functions (<span class="math inline">\(p = p_N\)</span> and the reference distribution <span class="math inline">\(p_0\)</span>), we need to construct intermediate log-probability functions given an annealing schedule <span class="math inline">\(0 = \beta_0 &lt; \beta_1 &lt; \cdots &lt; \beta_N\)</span>. To make everything vectorisable, let’s construct the individual kernels <span class="math inline">\(K_n\)</span> as <span class="math inline">\(K_n = \mathcal{K}(\phi_n)\)</span> using a factory function <span class="math inline">\(\mathcal{K}\)</span> and kernel-specific parameters <span class="math inline">\(\phi_n\)</span>.</p>
<p>Hence, this implementation is not as general as possible, but it should be compatible with JAX vectorised operations.</p>
<p>To swap the chains, we do a “full sweep”, attemping to swap <span class="math inline">\(x_0 \leftrightarrow x_1\)</span>, then <span class="math inline">\(x_1\leftrightarrow x_2\)</span>, and up to <span class="math inline">\(x_{N-1}\leftrightarrow x_N\)</span>. This choice is actually important, as we will later see.</p>
<div class="cell" data-execution_count="5">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_independent_annealed_kernel(</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  log_prob,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  log_ref,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  annealing_schedule,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  kernel_generator,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  params,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">tuple</span>:</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Generates the kernels via the kernel generator given appropriate parameters.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">  Args:</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">    log_prob: log_prob of the target distribution</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">    log_ref: log_prob of the easy-to-sample reference distribution</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">    annealing_schedule: annealing schedule such that `annealing_schedule[0] = 0.0` and `annealing_schedule[-1] = 1`</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">    kernel_generator: `kernel_generator(log_p, param)` returns a transition kernel of signature `kernel(key, state) -&gt; new_state`</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">    params: parameters for the transition kernels. Note that `len(annealing_schedule) = len(params)`</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">len</span>(annealing_schedule) <span class="op">!=</span> <span class="bu">len</span>(params):</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Parameters have to be of the same length as the annealing schedule"</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  n_chains <span class="op">=</span> <span class="bu">len</span>(annealing_schedule)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> transition_kernel(key, state, beta, param):</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> log_p(y):</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> beta <span class="op">*</span> log_prob(y) <span class="op">+</span> (<span class="fl">1.0</span> <span class="op">-</span> beta) <span class="op">*</span> log_ref(y)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kernel_generator(log_p, param)(key, state)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> kernel(key, state_joint):</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    key_vec <span class="op">=</span> jrandom.split(key, n_chains)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jax.vmap(transition_kernel, in_axes<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))(key_vec, state_joint, annealing_schedule, params)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> kernel</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_swap_chains_decision_kernel(</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>  log_prob,</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>  log_ref,</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>  annealing_schedule,</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> log_p(y, beta):</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> beta <span class="op">*</span> log_prob(y) <span class="op">+</span> (<span class="fl">1.0</span> <span class="op">-</span> beta) <span class="op">*</span> log_ref(y)</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> swap_decision(key, state, i: <span class="bu">int</span>, j: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    beta1, beta2 <span class="op">=</span> annealing_schedule[i], annealing_schedule[j]</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    x1, x2 <span class="op">=</span> state[i], state[j]</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    log_numerator <span class="op">=</span> log_p(x1, beta2) <span class="op">+</span> log_p(x2, beta1) </span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    log_denominator <span class="op">=</span> log_p(x1, beta1) <span class="op">+</span> log_p(x2, beta2)</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    log_r <span class="op">=</span> log_numerator <span class="op">-</span> log_denominator</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> jnp.exp(log_r)</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jrandom.uniform(key) <span class="op">&lt;</span> r</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> swap_decision</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_full_sweep_swap_kernel(</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>  log_prob,</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>  log_ref,</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>  annealing_schedule,</span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Applies a full sweep, attempting to swap chains 0 &lt;-&gt; 1, then 1 &lt;-&gt; 2 etc. one-after-another.</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>  n_chains <span class="op">=</span> <span class="bu">len</span>(annealing_schedule)</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> n_chains <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"At least two chains are needed."</span>)</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>  swap_decision_fn <span class="op">=</span> generate_swap_chains_decision_kernel(</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>    log_prob<span class="op">=</span>log_prob,</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    log_ref<span class="op">=</span>log_ref,</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>    annealing_schedule<span class="op">=</span>annealing_schedule,</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> kernel(key, state):</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(state, i: <span class="bu">int</span>):</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>      subkey <span class="op">=</span> jrandom.fold_in(key, i)</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>      decision <span class="op">=</span> swap_decision_fn(subkey, state<span class="op">=</span>state, i<span class="op">=</span>i, j<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Candidate state: we swap values at i and i+1 positions</span></span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>      swapped_state <span class="op">=</span> state.at[i].<span class="bu">set</span>(state[i<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>      swapped_state <span class="op">=</span> swapped_state.at[i<span class="op">+</span><span class="dv">1</span>].<span class="bu">set</span>(state[i])</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>      new_state <span class="op">=</span> jax.lax.select(decision, swapped_state, state)</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> new_state, <span class="va">None</span></span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>    final_state, _ <span class="op">=</span> jax.lax.scan(f, state, jnp.arange(n_chains <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> final_state</span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> kernel</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compose_kernels(kernels: <span class="bu">list</span>):</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Composes kernels, applying them in order."""</span></span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> kernel(key, state):</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ker <span class="kw">in</span> kernels:</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a>      key, subkey <span class="op">=</span> jrandom.split(key)</span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a>      state <span class="op">=</span> ker(subkey, state)</span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> state</span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> kernel</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We need also some annealing schedules:</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> annealing_constant(n_chains: <span class="bu">int</span>, base: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1.0</span>):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Constant annealing schedule, should be avoided."""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> base <span class="op">*</span> jnp.ones(n_chains)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> annealing_linear(n_chains: <span class="bu">int</span>):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Linear annealing schedule, should be avoided."""</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> jnp.linspace(<span class="fl">0.0</span>, <span class="fl">1.0</span>, n_chains)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> annealing_exponential(n_chains: <span class="bu">int</span>, base: <span class="bu">float</span> <span class="op">=</span> <span class="fl">2.0</span><span class="op">**</span><span class="fl">0.5</span>):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Annealing parameters form a geometric series (apart from beta[0] = 0).</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">  Args:</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">    n_chains: number of chains in the schedule</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">    base: geometric progression base, float larger than 1</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> base <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Base should be larger than 1."</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> n_chains <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"At least two chains are required."</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">elif</span> n_chains <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.array([<span class="fl">0.0</span>, <span class="fl">1.0</span>])</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> jnp.append(jnp.power(base, <span class="op">-</span>jnp.arange(n_chains <span class="op">-</span> <span class="dv">1</span>)), <span class="fl">0.0</span>)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x[::<span class="op">-</span><span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now we can re-run the previous experiment, but with the usual random-walk MCMC replaced with parallel tempering:</p>
<div class="cell" data-execution_count="7">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pt_multirun_sigmas(</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  key: RandomKey,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  sigmas: <span class="bu">list</span>[<span class="bu">float</span>],</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  distributions: OrderedDict,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  n_samples: <span class="bu">int</span>,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  warmup: <span class="bu">int</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  reference_scale: <span class="bu">float</span> <span class="op">=</span> <span class="fl">20.0</span>,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  n_chains: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  schedule_const: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1.1</span>,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  x0: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> log_ref(x):</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist.Normal(<span class="dv">0</span>, reference_scale).log_prob(x)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> sampling_fn(key, log_prob, sigma):</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    betas <span class="op">=</span> annealing_exponential(n_chains, schedule_const)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We know how to sample from the reference distribution </span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    sigmas <span class="op">=</span> sigma <span class="op">*</span> jnp.ones_like(betas)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    sigmas <span class="op">=</span> sigmas.at[<span class="dv">0</span>].<span class="bu">set</span>(reference_scale)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    K_ind <span class="op">=</span> generate_independent_annealed_kernel(</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>      log_prob<span class="op">=</span>log_prob,</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>      log_ref<span class="op">=</span>log_ref,</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>      annealing_schedule<span class="op">=</span>betas,</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>      kernel_generator<span class="op">=</span>generate_kernel,</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>      params<span class="op">=</span>sigmas,</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    K_swap <span class="op">=</span> generate_full_sweep_swap_kernel(</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>      log_prob<span class="op">=</span>log_prob,</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>      log_ref<span class="op">=</span>log_ref,</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>      annealing_schedule<span class="op">=</span>betas,</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    K_combined <span class="op">=</span> compose_kernels([K_ind, K_swap])</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mcmc_sampling_loop(</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>      key<span class="op">=</span>key,</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>      x0<span class="op">=</span>x0 <span class="op">*</span> jnp.ones(n_chains),</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>      kernel<span class="op">=</span>K_combined,</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>      n_samples<span class="op">=</span>n_samples,</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>      warmup<span class="op">=</span>warmup)</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> make_multirun(</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    key,</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    sampling_fn<span class="op">=</span>sampling_fn,</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    distributions<span class="op">=</span>distributions,</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    params<span class="op">=</span>sigmas,</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>_samples_pt <span class="op">=</span> pt_multirun_sigmas(</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>  sigmas<span class="op">=</span>SIGMAS,</span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">4_000</span>,</span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2000</span>,</span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Much better! Let’s take a look at the traces:</p>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-9-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>In fact, we can plot the traces corresponding to the auxiliary distributions. This distribution is closer to the reference, about in the middle:</p>
<div class="cell" data-execution_count="9">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>_middle_chain <span class="op">=</span> _samples_pt.shape[<span class="op">-</span><span class="dv">1</span>] <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., _middle_chain], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-10-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>And this one is just the reference distribution, from which we know how to sample well:</p>
<div class="cell" data-execution_count="10">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., <span class="dv">0</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-11-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="what-if" class="level3">
<h3 class="anchored" data-anchor-id="what-if">What if?</h3>
<p>Let’s understand parallel tempering better. The method has quite a few hyperparameters and we can understand what happens if we change them.</p>
<section id="reference-distribution" class="level4">
<h4 class="anchored" data-anchor-id="reference-distribution">Reference distribution</h4>
<p>Consider a “too narrow” reference distribution, which puts low mass in the region where the modes of the target distribution arise (in the multimodal case).</p>
<div class="cell" data-execution_count="11">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>_samples_pt <span class="op">=</span> pt_multirun_sigmas(</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  sigmas<span class="op">=</span>SIGMAS,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">4_000</span>,</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2000</span>,</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  reference_scale<span class="op">=</span><span class="fl">1.0</span>,</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-12-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="12">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-13-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We see some problems arising here. On the other hand, if choose a very wide distribution…</p>
<div class="cell" data-execution_count="13">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>_samples_pt <span class="op">=</span> pt_multirun_sigmas(</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  sigmas<span class="op">=</span>SIGMAS,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">4_000</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2000</span>,</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  reference_scale<span class="op">=</span><span class="fl">300.0</span>,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-14-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="14">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-15-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>… the behaviour of parallel tempering is somewhat better. Of course, not as good as when the reference <span class="math inline">\(p_0\)</span> was closer to the target <span class="math inline">\(p=p_N\)</span>, but my current intuition is that it is better to use a “too wide” reference, rather than “too narrow”.</p>
</section>
<section id="number-of-chains" class="level4">
<h4 class="anchored" data-anchor-id="number-of-chains">Number of chains</h4>
<p>Let’s try a smaller number of chains:</p>
<div class="cell" data-execution_count="15">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>_samples_pt <span class="op">=</span> pt_multirun_sigmas(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  sigmas<span class="op">=</span>SIGMAS,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">4_000</span>,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2000</span>,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  n_chains<span class="op">=</span><span class="dv">4</span>,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-16-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="16">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-17-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>This seems to be not bad, although the autocorrelation between samples is larger.</p>
<p>On the other hand, if we use a larger number of chains…</p>
<div class="cell" data-execution_count="17">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>_samples_pt <span class="op">=</span> pt_multirun_sigmas(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  sigmas<span class="op">=</span>SIGMAS,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">4_000</span>,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2000</span>,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  n_chains<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-18-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="18">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>… we see excellent results. As we will see below, there exist parallel tempering schemes in which a large number of chains results in a bad performance. However, the “full sweep” variant does not seem to suffer from this issue. (I may need to revise this intuition one day, when precise theory is available, but right now I am happy with it).</p>
</section>
<section id="annealing-schedule" class="level4">
<h4 class="anchored" data-anchor-id="annealing-schedule">Annealing schedule</h4>
<p>Finally, let’s take a look at the annealing schedule:</p>
<div class="cell" data-execution_count="19">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base <span class="kw">in</span> [<span class="fl">1.01</span>, <span class="fl">1.1</span>, <span class="fl">1.2</span>, <span class="fl">1.4</span>]:</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  schedule <span class="op">=</span> np.asarray(annealing_exponential(n_chains<span class="op">=</span><span class="dv">10</span>, base<span class="op">=</span>base)).tolist()</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  schedule_str <span class="op">=</span> <span class="st">", "</span>.join(<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="ss">f"</span><span class="sc">{</span>x<span class="sc">:.1f}</span><span class="ss">"</span>, schedule))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">:</span><span class="ch">\t</span><span class="sc">{</span>schedule_str<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1.01:   0.0, 0.9, 0.9, 0.9, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
1.1:    0.0, 0.5, 0.5, 0.6, 0.6, 0.7, 0.8, 0.8, 0.9, 1.0
1.2:    0.0, 0.2, 0.3, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 1.0
1.4:    0.0, 0.1, 0.1, 0.1, 0.2, 0.3, 0.4, 0.5, 0.7, 1.0</code></pre>
</div>
</div>
<p>Let’s use the constant 1.2:</p>
<div class="cell" data-execution_count="20">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>_samples_pt <span class="op">=</span> pt_multirun_sigmas(</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  sigmas<span class="op">=</span>SIGMAS,</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">4_000</span>,</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2000</span>,</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  schedule_const<span class="op">=</span><span class="fl">1.2</span>,</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-21-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="21">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-22-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Performance does not seem to differ by much.</p>
<p>Even if we use constant 2…</p>
<div class="cell" data-execution_count="22">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>_samples_pt <span class="op">=</span> pt_multirun_sigmas(</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  sigmas<span class="op">=</span>SIGMAS,</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">4_000</span>,</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2000</span>,</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  schedule_const<span class="op">=</span><span class="fl">2.0</span>,</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-23-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="23">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_pt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-24-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>… the performance is reasonable. This is interesting.</p>
</section>
</section>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">Summary</h3>
<p>My (current and subjective) intuition is that: - The most important thing is to ensure efficient sampling from the reference, <span class="math inline">\(p_0\)</span>, which should be somewhat close to <span class="math inline">\(p\)</span>. - It is better to use a bit “too wide” <span class="math inline">\(p_0\)</span> rather than a “too narrow” one. - We need efficient local exploration. Parallel tempering can however improve on these aspects. - The annealing schedule and the number of chains also do matter. I feel that the points considered above may be a bit more important for the final performance than tuning the optimisation schedule (e.g., 10-20 chains and around 1.1-1.2 annealing constant seem to be quite reasonable defaults), but choosing the number of chains and annealing schedule properly does matter. Also, we can often easily change the number of chains and the annealing schedule, while changing <span class="math inline">\(p_0\)</span> can be much more tricky (especially that in Bayesian inference problems, it often is taken to be the prior distribution, which cannot be changed arbitrarily).</p>
<p>These intuitions are based on “easy” low-dimensional problems considered above. However, for modern high-dimensional problems with many modes these intuitions may not generalise well. It is also much harder to ensure then that <span class="math inline">\(p_0\)</span> is reasonably wide and that the kernels are efficient enough.</p>
<p>It would be nice to have a good default for the annealing schedule. Another aspect, which we do not consider above, but is important for very high-dimensional problems, is to use distributed computing on multiple machines or parallel computing on multiple cores. While it is easy to parallelise application of the kernels <span class="math inline">\(K_n\)</span> to distinct components <span class="math inline">\(x_n\)</span>, our current “full sweep” swapping strategy has to be executed iteratively.</p>
</section>
</section>
<section id="non-reversible-parallel-tempering" class="level2">
<h2 class="anchored" data-anchor-id="non-reversible-parallel-tempering">Non-reversible parallel tempering</h2>
<p>In <a href="https://arxiv.org/abs/1905.02939"><em>Non-reversible parallel tempering: a scalable highly parallel MCMC scheme </em></a>, Saifuddin Syed, Alexandre Bouchard-Côté, George Deligiannidis and Arnaud Doucet propose an interesting alternative to the sampling scheme described above, suitable for distributed computing. I enjoyed reading the paper very much, but there is also <a href="https://youtu.be/9gOssrhN3EA?feature=shared">an excellent lecture available</a>.</p>
<p>Consider a distributed swapping scheme in which we do not want to sequentially attempt swapping chains <span class="math inline">\(i \leftrightarrow i+1\)</span> sequentially for all <span class="math inline">\(i=0, \dotsc, N-1\)</span>, but rather employ <em>either</em> an:</p>
<ol type="1">
<li><em>Even move</em>: attempt swapping the states <span class="math inline">\(2k \leftrightarrow 2k+1\)</span> (which can be done simultaneously for all <span class="math inline">\(k\)</span> on different machines).</li>
<li><em>Odd move</em>: attempt swapping the states <span class="math inline">\(2k-1 \leftrightarrow 2k\)</span> (which also can be done simultaneously for all <span class="math inline">\(k\)</span> on different machines).</li>
</ol>
<p>Note that both moves are different from what we did above: each full sweep swapped the states consequtively. In particular, there was a chance (very small, though) to travel from <span class="math inline">\(p_0\)</span> to <span class="math inline">\(p_N\)</span> in one full sweep (incurring <span class="math inline">\(N-1\)</span> swaps). Currently <span class="math inline">\(x_0\)</span> can either be swapped with <span class="math inline">\(x_1\)</span> (even move is accepted) or be left in place in one step (the odd move is executed or the even move is rejected).</p>
<p>The authors consider alternating between these moves basing on the following:</p>
<ol type="1">
<li>Stochastic even-odd swap (SEO): an unbiased coin is tossed to decide whether to execute the even or the odd move.</li>
<li>Deterministic even-odd swap (DEO): even time steps result in even moves and odd time steps result in odd moves.</li>
</ol>
<p>It turns out that SEO is a very inefficient choice when a large number of chains is used and DEO is much more preferred (see also <a href="#why-non-reversible-parallel-tempering">this section</a>).</p>
<section id="jax-implementation-of-deo" class="level3">
<h3 class="anchored" data-anchor-id="jax-implementation-of-deo">JAX implementation of DEO</h3>
<p>Let’s implement DEO in JAX.</p>
<p>Our first task is to execute even and odd moves, which deserves a subsection on its own.</p>
<section id="controlled-swapping-problem" class="level4">
<h4 class="anchored" data-anchor-id="controlled-swapping-problem">Controlled swapping problem</h4>
<p>We have a state <span class="math inline">\(\mathbf{x} = (x_0, \dotsc, x_N)\)</span> and we want to execute some moves. Let’s keep the information about the swaps in a binary mask matrix <span class="math inline">\(\mathbf{m} = (m_0, \dotsc, m_{N-1})\)</span> such that <span class="math inline">\(m_i = 1\)</span> if and only if we want to swap <span class="math inline">\(x_{i} \leftrightarrow x_{i+1}\)</span> (and <span class="math inline">\(m_i = 0\)</span> otherwise).</p>
<p>An even move in which (somewhat unlikely) all proposals are accepted has then a mask <span class="math inline">\(\mathbf{m}_\text{even} = (1, 0, 1, 0, \cdots)\)</span> and an odd move has a mask <span class="math inline">\(\mathbf{m}_\text{odd} = (0, 1, 0, 1, \cdots)\)</span>. However, as only some moves have been accepted, some ones can be replaced by zeros. Namely, if we have a binary matrix <span class="math inline">\(\mathbf{m}_\text{accept}\)</span>, we have to take the entry-wise AND operation. For example, <span class="math inline">\(\mathbf{m} := \mathbf{m}_\text{accept}\, \&amp;\, \mathbf{m}_\text{even}\)</span> for accepted even moves.</p>
<p>Note that it is not possible to have two consecutive ones.</p>
<p>I find applying the swaps according to <span class="math inline">\(\mathbf{m}\)</span> rather tricky. Consider the following algorithm:</p>
<pre><code>fn swapping_naive(x[], m[]) -&gt; y[]:
  for i = 0, ..., N-1:
    if m[i] = 0:
      y[i]   := x[i]
      y[i+1] := x[i+1]
    else:                 // m[i] = 1
      y[i]   := x[i+1]
      y[i+1] := x[i]</code></pre>
<p>Does it work?</p>
<p>No. For the input data</p>
<pre><code>m := [1, 0]
x := [a, b, c]</code></pre>
<p>we want <code>y = [b, a, c]</code>. However, we have:</p>
<pre><code>y := [b, a]       // i = 0, m[0] = 1
y := [b, b, c]    // i = 1, m[1] = 0</code></pre>
<p>The issue was that <code>y[1]</code> was updated both at <code>i=0</code> and <code>i=1</code> stages. Let’s think how we can improve this:</p>
<pre><code>fn swapping_good(x[], m[]) -&gt; y[]:
  y := copy(x)

  for i = 0, ..., N-1:
    if m[i] = 1:
      y[i]   := x[i+1]
      y[i+1] := x[i]
    else:                // m[i] = 0
      y[i]   := y[i]     // Note that we do not change the values
      y[i+1] := y[i+1]   // simply copying them over</code></pre>
<p>In this case, the algorithm works as following:</p>
<pre><code>y = [a, b, c]   // Before the loop
y = [b, a, c]   // i = 0, m[0] = 1
y = [b, a, c]   // i = 1, m[1] = 0</code></pre>
<p>Let’s prove that this algorithm is indeed correct by showing that each <code>y[i]</code> attains the correct value. We consider three cases:</p>
<p><strong>Case <code>y[0]</code></strong>: we have <code>y[0] := x[0]</code> at the beginning. The only moment when it can be modified is at step <code>i = 0</code>. We have <code>y[0] := y[0] = x[0]</code> if <code>m[0] = 0</code> and <code>y[0] := x[0+1] = x[1]</code> if <code>m[0] = 1</code>.</p>
<p><strong>Case <code>y[N]</code></strong>: similarly as above, <code>y[N] := x[N]</code> at the beginning and the only moment when it can be modified is at <code>i = N-1</code> step. If <code>m[N-1] = 0</code>, then <code>y[N] = x[N]</code> and if <code>m[N-1] = 1</code>, then we overwrite the value to <code>y[N] :=  x[N-1]</code>.</p>
<p><strong>Case <code>y[j]</code> for <code>0 &lt; j &lt; N</code></strong>: at the beginning <code>y[j] := x[j]</code> and can be modified only at steps <code>i=j-1</code> and <code>i=j</code>. We have three cases:</p>
<ul>
<li><code>m[j-1, j] = [0, 0]</code>. Then, <code>y[j] = x[j]</code> as it has not been modified at either step.</li>
<li><code>m[j-1, j] = [1, 0]</code>. Then <code>y[j] := x[j-1]</code> at <code>i=j-1</code> and stays unchanged at <code>i=j</code>, so in the end sequence we have <code>y[j] = x[j-1]</code>.</li>
<li><code>m[j-1, j] = [0, 1]</code>. Then, <code>y[j] = x[j]</code> at step <code>i=j-1</code>. Then, at step <code>i=j</code> we have <code>y[j] := x[j+1]</code>.</li>
</ul>
<p>Note that it is important that consecutive ones are not allowed.</p>
<div class="cell" data-execution_count="24">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _test_controlled_swapping(func):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  test_cases <span class="op">=</span> [</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Triples (x, m, y)</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    ([<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">0</span>,], [<span class="dv">1</span>, <span class="dv">2</span>]),</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    ([<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">1</span>,], [<span class="dv">2</span>, <span class="dv">1</span>]),</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]),</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]),</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>]),</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>]),</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>]),</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> x, m, y <span class="kw">in</span> test_cases:</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    y_ <span class="op">=</span> func(jnp.asarray(x), jnp.asarray(m))</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    y_ <span class="op">=</span> np.asarray(y_).tolist()</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">tuple</span>(y_) <span class="op">!=</span> <span class="bu">tuple</span>(y):</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"f(x=</span><span class="sc">{</span>x<span class="sc">}</span><span class="ss">, m=</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">) = </span><span class="sc">{</span>y_<span class="sc">}</span><span class="ss">. Expected </span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> controlled_swapping_scan(</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>  x: Float[Array, <span class="st">"n_chains *dims"</span>],</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>  m: Int[Array, <span class="st">" n_chains-1"</span>],</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">"n_chains *dims"</span>]:</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Swaps the entries of `x`, as described by binary mask `m`.</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a><span class="co">  Args:</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="co">    x: array of shape (n_chains, dim)</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a><span class="co">    m: binary mask of shape (n_chains - 1,) controlling which chains should be swapped. We have `m[i] = 1` if `x[i]` and `x[i+1]` should be swapped.</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a><span class="co">  Note:</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a><span class="co">    Consecutive values 1 in `m` are not allowed.</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="co">    Namely, it cannot hold that `m[i] = m[i+1] = 1`.</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> f(y, i):</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>    value <span class="op">=</span> jax.lax.select(m[i], x[i <span class="op">+</span> <span class="dv">1</span>], y[i])       <span class="co"># y[i]</span></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>    value_next <span class="op">=</span> jax.lax.select(m[i], x[i], y[i <span class="op">+</span> <span class="dv">1</span>])  <span class="co"># y[i + 1]</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> y.at[i].<span class="bu">set</span>(value)</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> y.at[i <span class="op">+</span> <span class="dv">1</span>].<span class="bu">set</span>(value_next)</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y, <span class="va">None</span></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Run the scan over the range of M</span></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>  y, _ <span class="op">=</span> jax.lax.scan(f, x, jnp.arange(m.shape[<span class="dv">0</span>]))</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> y</span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>_test_controlled_swapping(controlled_swapping_scan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This implementation seems to work and shows how powerful <code>[jax.lax.scan](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html)</code> can be. However, JAX is built to accelerate linear algebra and perhaps we can come up with an appropriately vectorised operation. Let’s go through the three cases once again.</p>
<p><strong>Case <code>y[0]</code></strong>: we want <code>x[0]</code> if <code>m[0] = 0</code> and <code>x[1]</code> if <code>m[1] = 1</code>. In other words, we have <code>y[0] = x[m[0]]</code>.</p>
<p><strong>Case <code>y[N]</code></strong>: we want <code>x[N-1]</code> if <code>m[N-1] = 1</code> and <code>x[N]</code> if <code>m[N-1] = 0</code>. Hence, <code>y[N] = x[N - m[N-1]]</code>.</p>
<p><strong>Case <code>y[j]</code> for <code>0 &lt; j &lt; N</code></strong>: as before, we have three cases, controlled by <code>m[j-1]</code> and <code>m[j]</code>. I claim that <code>y[j] = x[j + m[j] - m[j-1]]</code>. For both zeros, we do not swap anything and have <code>y[j] = x[j]</code>. For <code>m[j-1, j] = [0, 1]</code> we want to have <code>y[j] = x[j+1]</code> and for <code>m[j-1, j] = [1, 0]</code> we have <code>y[j] = x[j-1]</code>.</p>
<p>The implementation is now trivial:</p>
<div class="cell" data-execution_count="25">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _create_indices(m):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  N <span class="op">=</span> m.shape[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  base_indices <span class="op">=</span> jnp.arange(<span class="dv">1</span>, N<span class="op">-</span><span class="dv">1</span>)  <span class="co"># Length N-2</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  ind_middle <span class="op">=</span> base_indices <span class="op">+</span> m[<span class="dv">1</span>:] <span class="op">-</span> m[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  ind <span class="op">=</span> jnp.concatenate((</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        jnp.array([m[<span class="dv">0</span>]]),</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>        ind_middle,</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>        jnp.array([N <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> m[<span class="op">-</span><span class="dv">1</span>]])  </span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ind</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> controlled_swapping(</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>  x: Float[Array, <span class="st">"n_chains *dims"</span>],</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>  m: Int[Array, <span class="st">" n_chains-1"</span>],</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Float[Array, <span class="st">"n_chains *dims"</span>]:</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Swaps the entries of `x`, as described by binary mask `m`.</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a><span class="co">  Args:</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a><span class="co">    x: array of shape (n_chains, dim)</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a><span class="co">    m: binary mask of shape (n_chains - 1,) controlling which chains should be swapped. We have `m[i] = 1` if `x[i]` and `x[i+1]` should be swapped.</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a><span class="co">  Note:</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a><span class="co">    Consecutive values 1 in `m` are not allowed.</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a><span class="co">    Namely, it cannot hold that `m[i] = m[i+1] = 1`.</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>  indices <span class="op">=</span> _create_indices(m)</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x[indices, ...]</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>_test_controlled_swapping(controlled_swapping)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="deo-swapping-kernel-and-the-sampling-loop" class="level4">
<h4 class="anchored" data-anchor-id="deo-swapping-kernel-and-the-sampling-loop">DEO swapping kernel and the sampling loop</h4>
<p>At this stage, we can implement the swapping kernel. Note that this kernel has a different signature than usual, additionally taking the timestep as input and calculating the rejection rates, which will turn out to be useful <a href="#annealing-schedule-optimisation">when we optimise the annealing schedule</a>. Due to the fact that the swaps are not “interfering”, we can use vectorised operations.</p>
<div class="cell" data-execution_count="26">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_deo_extended_kernel(</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  log_prob,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  log_ref,</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  annealing_schedule,</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> log_p(y, beta):</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> beta <span class="op">*</span> log_prob(y) <span class="op">+</span> (<span class="fl">1.0</span> <span class="op">-</span> beta) <span class="op">*</span> log_ref(y)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  log_p_vmap <span class="op">=</span> jax.vmap(log_p, in_axes<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> extended_kernel(</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    key,</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    state,</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    timestep: <span class="bu">int</span>,</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>  ) <span class="op">-&gt;</span> <span class="bu">tuple</span>:</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Extended deterministic even-odd swap kernel, which</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a><span class="co">    for even timesteps makes even swaps (2i &lt;-&gt; 2i+1)</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a><span class="co">    and for odd timesteps makes odd swaps (2i-1 &lt;-&gt; 2i)</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="co">      key: random key</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a><span class="co">      state: state</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="co">      timestep: timestep number, used to decide whether to make even or odd move</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a><span class="co">      new_state, the same shape as `state`</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a><span class="co">      rejection_rates, shape (n_chains-1,)</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>    n_chains <span class="op">=</span> state.shape[<span class="dv">0</span>]</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>    idx1 <span class="op">=</span> jnp.arange(n_chains <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>    idx2 <span class="op">=</span> idx1 <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>    xs1 <span class="op">=</span> state[idx1]</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>    xs2 <span class="op">=</span> state[idx2]</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>    betas1 <span class="op">=</span> annealing_schedule[idx1]</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>    betas2 <span class="op">=</span> annealing_schedule[idx2]</span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>    log_numerator <span class="op">=</span> log_p_vmap(xs1, betas2) <span class="op">+</span> log_p_vmap(xs2, betas1) </span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>    log_denominator <span class="op">=</span> log_p_vmap(xs1, betas1) <span class="op">+</span> log_p_vmap(xs2, betas2)</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>    log_accept <span class="op">=</span> log_numerator <span class="op">-</span> log_denominator</span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a>    accept_prob <span class="op">=</span> jnp.minimum(jnp.exp(log_accept), <span class="fl">1.0</span>)</span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a>    rejection_rates <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> accept_prob</span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Where the swaps would be accepted through M-H</span></span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a>    accept_mask <span class="op">=</span> jrandom.bernoulli(key, p<span class="op">=</span>accept_prob)</span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Where the swaps can be accepted due to even-odd moves</span></span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a>    even_odd_mask <span class="op">=</span> jnp.mod(idx1, <span class="dv">2</span>) <span class="op">==</span> jnp.mod(timestep, <span class="dv">2</span>)</span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a>    total_mask <span class="op">=</span> accept_mask <span class="op">&amp;</span> even_odd_mask</span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-52"><a href="#cb34-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now the tricky part: we need to execute the swaps</span></span>
<span id="cb34-53"><a href="#cb34-53" aria-hidden="true" tabindex="-1"></a>    new_state <span class="op">=</span> controlled_swapping(state, total_mask)</span>
<span id="cb34-54"><a href="#cb34-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_state, rejection_rates</span>
<span id="cb34-55"><a href="#cb34-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-56"><a href="#cb34-56" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> extended_kernel</span>
<span id="cb34-57"><a href="#cb34-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-58"><a href="#cb34-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-59"><a href="#cb34-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> deo_sampling_loop(</span>
<span id="cb34-60"><a href="#cb34-60" aria-hidden="true" tabindex="-1"></a>  key: RandomKey,</span>
<span id="cb34-61"><a href="#cb34-61" aria-hidden="true" tabindex="-1"></a>  x0,</span>
<span id="cb34-62"><a href="#cb34-62" aria-hidden="true" tabindex="-1"></a>  kernel_local,</span>
<span id="cb34-63"><a href="#cb34-63" aria-hidden="true" tabindex="-1"></a>  kernel_deo,</span>
<span id="cb34-64"><a href="#cb34-64" aria-hidden="true" tabindex="-1"></a>  n_samples: <span class="bu">int</span>,</span>
<span id="cb34-65"><a href="#cb34-65" aria-hidden="true" tabindex="-1"></a>  warmup: <span class="bu">int</span>,</span>
<span id="cb34-66"><a href="#cb34-66" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">tuple</span>:</span>
<span id="cb34-67"><a href="#cb34-67" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""The sampling loop for DEO parallel tempering.</span></span>
<span id="cb34-68"><a href="#cb34-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-69"><a href="#cb34-69" aria-hidden="true" tabindex="-1"></a><span class="co">  Returns:</span></span>
<span id="cb34-70"><a href="#cb34-70" aria-hidden="true" tabindex="-1"></a><span class="co">    samples</span></span>
<span id="cb34-71"><a href="#cb34-71" aria-hidden="true" tabindex="-1"></a><span class="co">    rejection_rates</span></span>
<span id="cb34-72"><a href="#cb34-72" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb34-73"><a href="#cb34-73" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> f(x, timestep: <span class="bu">int</span>):</span>
<span id="cb34-74"><a href="#cb34-74" aria-hidden="true" tabindex="-1"></a>    subkey <span class="op">=</span> jrandom.fold_in(key, timestep)</span>
<span id="cb34-75"><a href="#cb34-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-76"><a href="#cb34-76" aria-hidden="true" tabindex="-1"></a>    key_local, key_deo <span class="op">=</span> jrandom.split(subkey)</span>
<span id="cb34-77"><a href="#cb34-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-78"><a href="#cb34-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply local exploration kernel</span></span>
<span id="cb34-79"><a href="#cb34-79" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> kernel_local(key_local, x)</span>
<span id="cb34-80"><a href="#cb34-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-81"><a href="#cb34-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply the DEO swap</span></span>
<span id="cb34-82"><a href="#cb34-82" aria-hidden="true" tabindex="-1"></a>    x, rejection_rates <span class="op">=</span> kernel_deo(</span>
<span id="cb34-83"><a href="#cb34-83" aria-hidden="true" tabindex="-1"></a>      key_deo,</span>
<span id="cb34-84"><a href="#cb34-84" aria-hidden="true" tabindex="-1"></a>      x,</span>
<span id="cb34-85"><a href="#cb34-85" aria-hidden="true" tabindex="-1"></a>      timestep,</span>
<span id="cb34-86"><a href="#cb34-86" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-87"><a href="#cb34-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-88"><a href="#cb34-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x, (x, rejection_rates)</span>
<span id="cb34-89"><a href="#cb34-89" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb34-90"><a href="#cb34-90" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Run warmup</span></span>
<span id="cb34-91"><a href="#cb34-91" aria-hidden="true" tabindex="-1"></a>  x0, _ <span class="op">=</span> jax.lax.scan(f, x0, jnp.arange(warmup))</span>
<span id="cb34-92"><a href="#cb34-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-93"><a href="#cb34-93" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Collect samples</span></span>
<span id="cb34-94"><a href="#cb34-94" aria-hidden="true" tabindex="-1"></a>  _, (samples, rejection_rates) <span class="op">=</span> jax.lax.scan(f, x0, jnp.arange(n_samples))</span>
<span id="cb34-95"><a href="#cb34-95" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb34-96"><a href="#cb34-96" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> samples, rejection_rates</span>
<span id="cb34-97"><a href="#cb34-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-98"><a href="#cb34-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-99"><a href="#cb34-99" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nonreversible_pt_multirun_sigmas(</span>
<span id="cb34-100"><a href="#cb34-100" aria-hidden="true" tabindex="-1"></a>  key: RandomKey,</span>
<span id="cb34-101"><a href="#cb34-101" aria-hidden="true" tabindex="-1"></a>  sigmas: <span class="bu">list</span>[<span class="bu">float</span>],</span>
<span id="cb34-102"><a href="#cb34-102" aria-hidden="true" tabindex="-1"></a>  distributions: OrderedDict,</span>
<span id="cb34-103"><a href="#cb34-103" aria-hidden="true" tabindex="-1"></a>  n_samples: <span class="bu">int</span>,</span>
<span id="cb34-104"><a href="#cb34-104" aria-hidden="true" tabindex="-1"></a>  warmup: <span class="bu">int</span>,</span>
<span id="cb34-105"><a href="#cb34-105" aria-hidden="true" tabindex="-1"></a>  reference_scale: <span class="bu">float</span> <span class="op">=</span> <span class="fl">20.0</span>,</span>
<span id="cb34-106"><a href="#cb34-106" aria-hidden="true" tabindex="-1"></a>  n_chains: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>,</span>
<span id="cb34-107"><a href="#cb34-107" aria-hidden="true" tabindex="-1"></a>  schedule_const: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1.1</span>,</span>
<span id="cb34-108"><a href="#cb34-108" aria-hidden="true" tabindex="-1"></a>  x0: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span id="cb34-109"><a href="#cb34-109" aria-hidden="true" tabindex="-1"></a>  annealing_schedule: Float[Array, <span class="st">" n_chains"</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb34-110"><a href="#cb34-110" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb34-111"><a href="#cb34-111" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> annealing_schedule <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb34-112"><a href="#cb34-112" aria-hidden="true" tabindex="-1"></a>    betas <span class="op">=</span> annealing_exponential(n_chains<span class="op">=</span>n_chains, base<span class="op">=</span>schedule_const)</span>
<span id="cb34-113"><a href="#cb34-113" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb34-114"><a href="#cb34-114" aria-hidden="true" tabindex="-1"></a>    betas <span class="op">=</span> jnp.asarray(annealing_schedule)</span>
<span id="cb34-115"><a href="#cb34-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-116"><a href="#cb34-116" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> log_ref(x):</span>
<span id="cb34-117"><a href="#cb34-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist.Normal(<span class="dv">0</span>, reference_scale).log_prob(x)</span>
<span id="cb34-118"><a href="#cb34-118" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb34-119"><a href="#cb34-119" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> sampling_fn(key, log_prob, sigma):</span>
<span id="cb34-120"><a href="#cb34-120" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We know how to sample from the reference distribution </span></span>
<span id="cb34-121"><a href="#cb34-121" aria-hidden="true" tabindex="-1"></a>    sigmas <span class="op">=</span> sigma <span class="op">*</span> jnp.ones_like(betas)</span>
<span id="cb34-122"><a href="#cb34-122" aria-hidden="true" tabindex="-1"></a>    sigmas <span class="op">=</span> sigmas.at[<span class="dv">0</span>].<span class="bu">set</span>(reference_scale)</span>
<span id="cb34-123"><a href="#cb34-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-124"><a href="#cb34-124" aria-hidden="true" tabindex="-1"></a>    K_ind <span class="op">=</span> generate_independent_annealed_kernel(</span>
<span id="cb34-125"><a href="#cb34-125" aria-hidden="true" tabindex="-1"></a>      log_prob<span class="op">=</span>log_prob,</span>
<span id="cb34-126"><a href="#cb34-126" aria-hidden="true" tabindex="-1"></a>      log_ref<span class="op">=</span>log_ref,</span>
<span id="cb34-127"><a href="#cb34-127" aria-hidden="true" tabindex="-1"></a>      annealing_schedule<span class="op">=</span>betas,</span>
<span id="cb34-128"><a href="#cb34-128" aria-hidden="true" tabindex="-1"></a>      kernel_generator<span class="op">=</span>generate_kernel,</span>
<span id="cb34-129"><a href="#cb34-129" aria-hidden="true" tabindex="-1"></a>      params<span class="op">=</span>sigmas,</span>
<span id="cb34-130"><a href="#cb34-130" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-131"><a href="#cb34-131" aria-hidden="true" tabindex="-1"></a>    K_deo <span class="op">=</span> generate_deo_extended_kernel(</span>
<span id="cb34-132"><a href="#cb34-132" aria-hidden="true" tabindex="-1"></a>      log_prob<span class="op">=</span>log_prob,</span>
<span id="cb34-133"><a href="#cb34-133" aria-hidden="true" tabindex="-1"></a>      log_ref<span class="op">=</span>log_ref,</span>
<span id="cb34-134"><a href="#cb34-134" aria-hidden="true" tabindex="-1"></a>      annealing_schedule<span class="op">=</span>betas,</span>
<span id="cb34-135"><a href="#cb34-135" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-136"><a href="#cb34-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-137"><a href="#cb34-137" aria-hidden="true" tabindex="-1"></a>    key, subkey <span class="op">=</span> jrandom.split(key)</span>
<span id="cb34-138"><a href="#cb34-138" aria-hidden="true" tabindex="-1"></a>    samples, rejections <span class="op">=</span> deo_sampling_loop(</span>
<span id="cb34-139"><a href="#cb34-139" aria-hidden="true" tabindex="-1"></a>      key<span class="op">=</span>subkey,</span>
<span id="cb34-140"><a href="#cb34-140" aria-hidden="true" tabindex="-1"></a>      x0<span class="op">=</span>x0 <span class="op">*</span> jnp.ones(n_chains, dtype<span class="op">=</span><span class="bu">float</span>),</span>
<span id="cb34-141"><a href="#cb34-141" aria-hidden="true" tabindex="-1"></a>      kernel_local<span class="op">=</span>K_ind,</span>
<span id="cb34-142"><a href="#cb34-142" aria-hidden="true" tabindex="-1"></a>      kernel_deo<span class="op">=</span>K_deo,</span>
<span id="cb34-143"><a href="#cb34-143" aria-hidden="true" tabindex="-1"></a>      n_samples<span class="op">=</span>n_samples,</span>
<span id="cb34-144"><a href="#cb34-144" aria-hidden="true" tabindex="-1"></a>      warmup<span class="op">=</span>warmup,</span>
<span id="cb34-145"><a href="#cb34-145" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-146"><a href="#cb34-146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> samples</span>
<span id="cb34-147"><a href="#cb34-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-148"><a href="#cb34-148" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> make_multirun(</span>
<span id="cb34-149"><a href="#cb34-149" aria-hidden="true" tabindex="-1"></a>    key,</span>
<span id="cb34-150"><a href="#cb34-150" aria-hidden="true" tabindex="-1"></a>    sampling_fn<span class="op">=</span>sampling_fn,</span>
<span id="cb34-151"><a href="#cb34-151" aria-hidden="true" tabindex="-1"></a>    distributions<span class="op">=</span>distributions,</span>
<span id="cb34-152"><a href="#cb34-152" aria-hidden="true" tabindex="-1"></a>    params<span class="op">=</span>sigmas,</span>
<span id="cb34-153"><a href="#cb34-153" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="27">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>_samples_npt <span class="op">=</span> nonreversible_pt_multirun_sigmas(</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  sigmas<span class="op">=</span>SIGMAS,</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  distributions<span class="op">=</span>DISTRIBUTIONS,</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">4000</span>,</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2000</span>,</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>plot_histograms(SAMPLES_EXACT, _samples_npt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-28-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="28">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>plot_traces(_samples_npt[..., <span class="op">-</span><span class="dv">1</span>], params<span class="op">=</span>SIGMAS, param_name<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">sigma$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-29-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>This seems pretty good to me!</p>
</section>
</section>
<section id="why-non-reversible-parallel-tempering" class="level3">
<h3 class="anchored" data-anchor-id="why-non-reversible-parallel-tempering">Why non-reversible parallel tempering?</h3>
<p>Interestingly, DEO has better performance than SEO, which are termed in the paper, respectively, non-reversible and reversible parallel tempering schemes. The discussion whether to use non-reversible or reversible kernels has a long history and I still find the topic mysterious. Probably it is worth to write a separate blog post on the topic, but:</p>
<ul>
<li>This wonderful 2000 paper from <a href="https://doi.org/10.1214/aoap/1019487508">Persi Diaconis, Susan Holmes and Radford Neal</a> shows examples where non-reversible methods are more efficient than reversible ones.</li>
<li>In a <a href="https://doi.org/10.5539/ijsp.v5n1p51">great 2016 paper from Gareth Roberts and Jeffrey Rosenthal</a> there are examples where “systematic scan” Gibbs samplers (which often are non-reversible, although not always: recall palindromic kernels of the form <span class="math inline">\(K_1 K_2 K_1\)</span>) can outperform “random scan” (always reversible) Gibbs samplers. Examples with the <em>opposite behaviour</em> are also provided.</li>
<li>In a 2016 <a href="https://www.jstor.org/stable/26363466">C. Andrieu’s paper</a> there is a theorem showing that for two kernels fulfilling some technical assumptions, systematic scans are more efficient than random ones. This could perhaps offer an orthogonal perspective on why DEO is more efficient than SEO, but I am not sure.</li>
</ul>
<p>This discussion whether reversible or non-reversible scheme could be used is one way of looking at the problem. Another is through the perspective of reducing the diffusive random walk behaviour by introducing a momentum variable. Momentum is a common theme in computational statistics and machine learning, with examples such as <a href="https://en.wikipedia.org/wiki/Metropolis-adjusted_Langevin_algorithm">MALA</a> and <a href="https://en.wikipedia.org/wiki/Hamiltonian_Monte_Carlo">Hamiltonian Monte Carlo</a> in Markov chain Monte Carlo world or <a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Momentum">stochastic gradient descent with momentum</a> in optimisation.</p>
<p>DEO reduces random walk in swapping the chains (which is studied through the perspective of an <em>index process</em>) and can be thought as of introducing a (discrete) momentum variable. I will skip the precise description of the index process, replacing it with a picture I based on the figures from the paper. We will simulate the path of the chain under the sequential scheme we studied before, SEO and DEO:</p>
<div class="cell" data-execution_count="29">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _find_trajectory(states, tracked: <span class="bu">int</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  n_chains <span class="op">=</span> states.shape[<span class="dv">1</span>]</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> tracked <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    tracked <span class="op">=</span> n_chains <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> jnp.einsum(<span class="st">"ng,g-&gt;n"</span>, states <span class="op">==</span> tracked, jnp.arange(n_chains))</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_figure_momentum(p: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.85</span>, n_chains: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>, n_timesteps: <span class="bu">int</span> <span class="op">=</span> <span class="dv">30</span>):</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  rng <span class="op">=</span> np.random.default_rng(<span class="dv">8</span>)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>  fig, axs <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  x_axis <span class="op">=</span> np.arange(n_timesteps)</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> ax <span class="kw">in</span> axs:</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> chain <span class="kw">in</span> <span class="bu">range</span>(n_chains):</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>      ax.scatter(x_axis, chain <span class="op">*</span> np.ones_like(x_axis), c<span class="op">=</span><span class="st">"w"</span>, s<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    ax.spines[[<span class="st">"top"</span>, <span class="st">"right"</span>]].set_visible(<span class="va">False</span>)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sample full sweep</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>  state <span class="op">=</span> jnp.arange(n_chains)</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>  states <span class="op">=</span> [state]</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> timestep <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_timesteps):</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_chains <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> rng.binomial(<span class="dv">1</span>, p):</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>        new_state <span class="op">=</span> state.at[i].<span class="bu">set</span>(state[i<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>        new_state <span class="op">=</span> new_state.at[i<span class="op">+</span><span class="dv">1</span>].<span class="bu">set</span>(state[i])</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> new_state</span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>    states.append(state)</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>  states <span class="op">=</span> jnp.stack(states)</span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>  trajectory <span class="op">=</span> _find_trajectory(states)</span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>  ax <span class="op">=</span> axs[<span class="dv">0</span>]</span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>  ax.plot(x_axis, trajectory)</span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>  ax.set_title(<span class="st">"Full sweep"</span>)</span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sample SEO</span></span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>  state <span class="op">=</span> jnp.arange(n_chains)</span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>  states <span class="op">=</span> [state]</span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> timestep <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_timesteps):</span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>    mode <span class="op">=</span> rng.binomial(<span class="dv">1</span>, <span class="fl">0.5</span>)</span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_chains <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> mode) <span class="kw">and</span> rng.binomial(<span class="dv">1</span>, p):</span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>        new_state <span class="op">=</span> state.at[i].<span class="bu">set</span>(state[i<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>        new_state <span class="op">=</span> new_state.at[i<span class="op">+</span><span class="dv">1</span>].<span class="bu">set</span>(state[i])</span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> new_state</span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>    states.append(state)</span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a>  states <span class="op">=</span> jnp.stack(states)</span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a>  trajectory <span class="op">=</span> _find_trajectory(states)</span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a>  ax <span class="op">=</span> axs[<span class="dv">1</span>]</span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a>  ax.plot(x_axis, trajectory)</span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>  ax.set_title(<span class="st">"Reversible stochastic even-odd swaps (SEO)"</span>)</span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sample DEO</span></span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a>  state <span class="op">=</span> jnp.arange(n_chains)</span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a>  states <span class="op">=</span> [state]</span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> timestep <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_timesteps):</span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_chains <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> timestep <span class="op">%</span> <span class="dv">2</span>) <span class="kw">and</span> rng.binomial(<span class="dv">1</span>, p):</span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a>        new_state <span class="op">=</span> state.at[i].<span class="bu">set</span>(state[i<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a>        new_state <span class="op">=</span> new_state.at[i<span class="op">+</span><span class="dv">1</span>].<span class="bu">set</span>(state[i])</span>
<span id="cb37-66"><a href="#cb37-66" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> new_state</span>
<span id="cb37-67"><a href="#cb37-67" aria-hidden="true" tabindex="-1"></a>    states.append(state)</span>
<span id="cb37-68"><a href="#cb37-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-69"><a href="#cb37-69" aria-hidden="true" tabindex="-1"></a>  states <span class="op">=</span> jnp.stack(states)</span>
<span id="cb37-70"><a href="#cb37-70" aria-hidden="true" tabindex="-1"></a>  trajectory <span class="op">=</span> _find_trajectory(states)</span>
<span id="cb37-71"><a href="#cb37-71" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb37-72"><a href="#cb37-72" aria-hidden="true" tabindex="-1"></a>  ax <span class="op">=</span> axs[<span class="dv">2</span>]</span>
<span id="cb37-73"><a href="#cb37-73" aria-hidden="true" tabindex="-1"></a>  ax.plot(x_axis, trajectory)</span>
<span id="cb37-74"><a href="#cb37-74" aria-hidden="true" tabindex="-1"></a>  ax.set_title(<span class="st">"Non-reversible deterministic even-odd swaps (DEO)"</span>)</span>
<span id="cb37-75"><a href="#cb37-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-76"><a href="#cb37-76" aria-hidden="true" tabindex="-1"></a>  fig.tight_layout()</span>
<span id="cb37-77"><a href="#cb37-77" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> fig</span>
<span id="cb37-78"><a href="#cb37-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-79"><a href="#cb37-79" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> generate_figure_momentum(p<span class="op">=</span><span class="fl">0.8</span>, n_chains<span class="op">=</span><span class="dv">4</span>, n_timesteps<span class="op">=</span><span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-30-output-1.png" width="662" height="470"></p>
</div>
</div>
<div class="cell" data-execution_count="30">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> generate_figure_momentum(p<span class="op">=</span><span class="fl">0.9</span>, n_chains<span class="op">=</span><span class="dv">10</span>, n_timesteps<span class="op">=</span><span class="dv">50</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-31-output-1.png" width="662" height="470"></p>
</div>
</div>
<p>Definitely, SEO has a trouble going between the reference and the target distribution. On the other hand, in these simulations (which are very simplistic, though!), DEO does not show a clear advantage over the full sweep (other than being more parallelisable). Note that both SEO and DEO can move an index only by <span class="math inline">\(\pm 1\)</span>, while the full sweep can increase the index arbitrarily. However, it also decreases the indices at most by <span class="math inline">\(1\)</span>. It may perhaps be interesting to consider a <em>deterministic forward-backward full sweep scheme</em>, in which even timesteps make a full forward sweep (as we did in the first prototype) and odd timesteps make a backward sweep.</p>
<p>I think studying the behaviour of the DEO scheme is an important contribution of this paper, but there several more:</p>
<ol type="1">
<li>By introducing and studying the index process, the authors devise the DEO sampling scheme together with a method for <em>choosing the annealing schedule</em> basing on preliminary runs.</li>
<li>The proposed sampling scheme is highly parallelisable and can be used in distributed computing environments. The experiments in the paper cover many complex high-dimensional distributions. Moreover, a new Julia package, <a href="https://pigeons.run/">Pigeons.jl</a> makes application of non-reversible parallel tempering practical in the distributed setting.</li>
</ol>
<p>Let’s see, however, how to tune the annealing schedule, which has a wonderful theory outlined in Section 4 of the paper.</p>
</section>
<section id="annealing-schedule-optimisation" class="level3">
<h3 class="anchored" data-anchor-id="annealing-schedule-optimisation">Annealing schedule optimisation</h3>
<p>Assuming efficient local exploration of individual components, the authors build a theory how quickly the chain can cycle between <span class="math inline">\(p_0\)</span> and <span class="math inline">\(p=p_N\)</span>. The key quantity is the <em>instateneous rejection rate</em> function <span class="math display">\[
  \lambda(\beta) = \frac{1}{2} \mathbb E_{X, Y \sim_\mathrm{i.i.d.} p_\beta } \left[\left| \log \frac{ p(X) p_0(Y)}{ p(Y) p_0(X) } \right|\right],
\]</span></p>
<p>which depends on the annealing parameter <span class="math inline">\(\beta\)</span> (which controls the measure over which we integrate), but also on how different <span class="math inline">\(p\)</span> and <span class="math inline">\(p_0\)</span> are. Define <span class="math display">\[
  \Lambda(\beta) = \int_{0}^{\beta} \lambda(\beta') \,\mathrm{d}\beta'.
\]</span></p>
<p>If <span class="math inline">\(\tilde \Lambda = \Lambda(1)\)</span>, then for small <span class="math inline">\(\max_i |\beta_i - \beta_{i+1}|\)</span> it holds that the “round-trip rate”, describing how often going from <span class="math inline">\(p_0\)</span> to <span class="math inline">\(p\)</span> and back, for SEO is about <span class="math display">\[
  f_\mathrm{SEO} \approx \frac{1}{2N + 2\tilde \Lambda}.
\]</span></p>
<p>Using a large <span class="math inline">\(N\)</span> for SEO leads to diffusive behaviour with close-to-zero round-trip rate! I find this result amazing. What is even more interesting, for DEO: <span class="math display">\[
  f_\mathrm{DEO} \approx \frac{1}{2 \cdot \left(1+\tilde \Lambda\right)}.
\]</span></p>
<p>DEO with large <span class="math inline">\(N\)</span> does not have the diffusive behaviour, with the round-trip rate being controlled by the <em>communication barrier</em> <span class="math inline">\(\tilde \Lambda\)</span>, which depends on <span class="math inline">\(p_0\)</span> and <span class="math inline">\(p\)</span>. Hence, for large <span class="math inline">\(\tilde\Lambda\)</span> many, many iterations may be necessary to obtain enough round trips and good mixing.</p>
<p>Interestingly, the <span class="math inline">\(\Lambda\)</span> function can be estimated from a run using a fine-grained annealing schedule. It turns out that if <span class="math inline">\(\rho(\beta, \beta')\)</span> is the expected rejection rate of swapping the chains between <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\beta'\)</span> (so that, of course, <span class="math inline">\(\rho(\beta, \beta') = \rho(\beta', \beta)\)</span>), then <span class="math display">\[
  \rho(\beta, \beta') = | \Lambda(\beta) - \Lambda(\beta') | + O(|\beta - \beta'|^3).
\]</span></p>
<p>In particular, <span class="math display">\[
  \tilde \Lambda \approx \sum_{i=0}^{N-1} \rho(\beta_{i}, \beta_{i+1}),
\]</span></p>
<p>where the error is of order <span class="math inline">\(O\!\left(N \cdot \left(\max_i |\beta_i - \beta_{i+1}|\right)^3 \right)\)</span>.</p>
<p>In other words, <span class="math inline">\(\Lambda(\beta)\)</span> can be estimated from the rejection probabilities.</p>
<p>To optimise the schedule, the authors note that the round-trip rate under DEO is given by <span class="math display">\[
  f = \frac{1}{2\left(1 + \sum_{i=0}^{N-1} \frac{\rho(\beta_{i}, \beta_{i+1})}{ 1-\rho(\beta_i, \beta_{i+1}) } \right)}
\]</span></p>
<p>for any schedule. (Note that the approximation of <span class="math inline">\(f_\mathrm{DEO}\)</span> when differences <span class="math inline">\(|\beta_i - \beta_{i+1}|\)</span> are small, can be read from this formula: all <span class="math inline">\(\rho\)</span> are small, so we can ignore terms <span class="math inline">\(1-\rho\)</span> and then we obtain <span class="math inline">\(\tilde \Lambda\)</span>).</p>
<p>As we want to maximise <span class="math inline">\(f\)</span>, we need to find a schedule minimising the denominator. On the other hand, there is a constraint that for any fine-grained schedule it holds that</p>
<p><span class="math display">\[
  \tilde \Lambda \approx \sum_{i=0}^{N-1} \rho(\beta_{i}, \beta_{i+1}),
\]</span></p>
<p>so that this is a constrained optimisation problem. It turns out that the optimum is attained when <span class="math inline">\(\rho(\beta_i, \beta_{i+1})\)</span> are all equal. Using the relationship between <span class="math inline">\(\rho\)</span> and differences in <span class="math inline">\(\Lambda\)</span>, we see that we should aim at <span class="math display">\[
  \Lambda(\beta_i) \approx \frac{i}{N} \tilde \Lambda.
\]</span></p>
<section id="jax-implementation-1" class="level4">
<h4 class="anchored" data-anchor-id="jax-implementation-1">JAX implementation</h4>
<div class="cell" data-execution_count="31">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> PchipInterpolator</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> bisect</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> estimate_lambda_values(rejection_rates, offset: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-3</span>):</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Make sure that the estimated rejection rates are non-zero</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  rejection_rates <span class="op">=</span> jnp.maximum(rejection_rates, offset)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We have Lambda(0) = 0 and then estimate the rest by cumulative sums</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  extended <span class="op">=</span> jnp.concatenate((jnp.zeros(<span class="dv">1</span>), rejection_rates))</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> jnp.cumsum(extended)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_lambda_function(</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  annealing_schedule,</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  lambda_values,</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Approximates the Lambda function from several estimates at the schedule by interpolating the values with a monotonic cubic spline (as advised in the paper)."""</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> PchipInterpolator(annealing_schedule, lambda_values)</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> annealing_optimal(</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>  n_chains: <span class="bu">int</span>,</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>  previous_schedule,</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>  rejection_rates,</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>  _offset: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-3</span>,</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Finds the optimal annealing schedule basing on the approximation of the Lambda function."""</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>  lambda_values <span class="op">=</span> estimate_lambda_values(rejection_rates, offset<span class="op">=</span>_offset)</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>  lambda_fn <span class="op">=</span> get_lambda_function(</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>    previous_schedule,</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>    lambda_values,</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>  lambda1 <span class="op">=</span> lambda_values[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>  new_schedule <span class="op">=</span> [<span class="fl">0.0</span>]</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_chains <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fn(x):</span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>      desired_value <span class="op">=</span> k <span class="op">*</span> lambda1 <span class="op">/</span> (n_chains <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> lambda_fn(x) <span class="op">-</span> desired_value</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>    new_point <span class="op">=</span> bisect(</span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>      fn,</span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>      new_schedule[<span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>      <span class="fl">1.0</span>,</span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> new_point <span class="op">&gt;=</span> <span class="fl">1.0</span>:</span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>      <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Encountered value 1.0."</span>)</span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a>    new_schedule.append(new_point)</span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>  new_schedule.append(<span class="fl">1.0</span>)</span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">len</span>(new_schedule) <span class="op">!=</span> n_chains:</span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"This should not happen."</span>)</span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> jnp.asarray(new_schedule, dtype<span class="op">=</span><span class="bu">float</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s apply these utilities to suggest better annealing schedules for one of the problems above.</p>
<div class="cell" data-execution_count="32">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_nonversible_pt(</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  key: RandomKey,</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  sigma: <span class="bu">float</span>,</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  distribution_factory,</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  n_samples: <span class="bu">int</span>,</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  warmup: <span class="bu">int</span>,</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  annealing_schedule: Float[Array, <span class="st">" n_chains"</span>],</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  reference_scale: <span class="bu">float</span> <span class="op">=</span> <span class="fl">20.0</span>,</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>  x0: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  betas <span class="op">=</span> jnp.asarray(annealing_schedule)</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>  n_chains <span class="op">=</span> betas.shape[<span class="dv">0</span>]</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> log_ref(x):</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist.Normal(<span class="dv">0</span>, reference_scale).log_prob(x)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> sampling_fn(key, log_prob, sigma):</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We know how to sample from the reference distribution </span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>    sigmas <span class="op">=</span> sigma <span class="op">*</span> jnp.ones_like(betas)</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>    sigmas <span class="op">=</span> sigmas.at[<span class="dv">0</span>].<span class="bu">set</span>(reference_scale)</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    K_ind <span class="op">=</span> generate_independent_annealed_kernel(</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>      log_prob<span class="op">=</span>log_prob,</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>      log_ref<span class="op">=</span>log_ref,</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>      annealing_schedule<span class="op">=</span>betas,</span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>      kernel_generator<span class="op">=</span>generate_kernel,</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>      params<span class="op">=</span>sigmas,</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>    K_deo <span class="op">=</span> generate_deo_extended_kernel(</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>      log_prob<span class="op">=</span>log_prob,</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>      log_ref<span class="op">=</span>log_ref,</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>      annealing_schedule<span class="op">=</span>betas,</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>    key, subkey <span class="op">=</span> jrandom.split(key)</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>    samples, rejections <span class="op">=</span> deo_sampling_loop(</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>      key<span class="op">=</span>subkey,</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>      x0<span class="op">=</span>x0 <span class="op">*</span> jnp.ones(n_chains, dtype<span class="op">=</span><span class="bu">float</span>),</span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>      kernel_local<span class="op">=</span>K_ind,</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>      kernel_deo<span class="op">=</span>K_deo,</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>      n_samples<span class="op">=</span>n_samples,</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>      warmup<span class="op">=</span>warmup,</span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> samples, rejections</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> log_prob(x):</span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> distribution_factory().log_prob(x)</span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sampling_fn(key, log_prob, sigma)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We use 20 chains and an exponential schedule, supposed to decay too quickly:</p>
<div class="cell" data-execution_count="33">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>_N_CHAINS <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>_CURRENT_DIST <span class="op">=</span> mixture3_dist</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>initial_schedule <span class="op">=</span> annealing_exponential(n_chains<span class="op">=</span>_N_CHAINS, base<span class="op">=</span><span class="fl">3.0</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>samples, rejections <span class="op">=</span> run_nonversible_pt(</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  sigma<span class="op">=</span><span class="fl">1.0</span>,</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  distribution_factory<span class="op">=</span>_CURRENT_DIST,</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">5_000</span>,</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2_000</span>,</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  annealing_schedule<span class="op">=</span>initial_schedule,</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s calculate a new schedule and collect a new sample:</p>
<div class="cell" data-execution_count="34">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>_mean_rejections <span class="op">=</span> rejections.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>_lambda_vals <span class="op">=</span> estimate_lambda_values(_mean_rejections)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>_lambda_fn <span class="op">=</span> get_lambda_function(initial_schedule, _lambda_vals)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>new_schedule <span class="op">=</span> annealing_optimal(</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  initial_schedule.shape[<span class="dv">0</span>],</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  initial_schedule,</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  _mean_rejections,</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>new_samples, new_rejections <span class="op">=</span> run_nonversible_pt(</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>  key<span class="op">=</span>RNG_JAX.key,</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>  sigma<span class="op">=</span><span class="fl">1.0</span>,</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>  distribution_factory<span class="op">=</span>_CURRENT_DIST,</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>  n_samples<span class="op">=</span><span class="dv">5_000</span>,</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>  warmup<span class="op">=</span><span class="dv">2_000</span>,</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>  annealing_schedule<span class="op">=</span>new_schedule,</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>_new_mean_rejections <span class="op">=</span> new_rejections.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>_new_lambda_vals <span class="op">=</span> estimate_lambda_values(_new_mean_rejections)</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>_new_lambda_fn <span class="op">=</span> get_lambda_function(new_schedule, _new_lambda_vals)</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>very_new_schedule <span class="op">=</span> annealing_optimal(</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>  new_schedule.shape[<span class="dv">0</span>],</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>  new_schedule,</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>  _new_mean_rejections,</span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We have now:</p>
<ul>
<li>two samples: using initial (very quickly decaying schedule) and an optimised one,</li>
<li>two estimates of the <span class="math inline">\(\Lambda(\beta)\)</span> function (each estimate depends on the schedule and the rejection rates collected during sampling),</li>
<li>three schedules: the initial one (decaying one), the optimised schedule (for which we also collected a sample), and a third, “very optimised”, schedule (which we estimated using the second one).</li>
</ul>
<p>We hope that:</p>
<ol type="1">
<li>The second sample will be better than the first one (as the schedule now should be better).</li>
<li>The <span class="math inline">\(\Lambda(\beta)\)</span> estimates will somewhat agree.</li>
<li>The second schedule will be much different than the second one. On the other hand, we can hope that the third schedule will be close to the second one (as it depends on the <span class="math inline">\(\Lambda\)</span> function and we hope that the estimates are reasonable).</li>
</ol>
<p>Let’s see how this works:</p>
<div class="cell" data-execution_count="35">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span>, <span class="dv">4</span> <span class="op">*</span> <span class="dv">2</span>), dpi<span class="op">=</span><span class="dv">350</span>, sharex<span class="op">=</span><span class="st">"row"</span>, sharey<span class="op">=</span><span class="st">"row"</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>_sample_true <span class="op">=</span> _CURRENT_DIST().sample(RNG_JAX.key, (<span class="dv">5_000</span>,)) </span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>_BINS <span class="op">=</span> np.concatenate([</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  np.linspace(<span class="op">-</span><span class="dv">40</span>, <span class="op">-</span><span class="dv">20</span>, <span class="dv">30</span>),</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>  np.linspace(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">30</span>),</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>  np.linspace(<span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">30</span>),</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">"Samples"</span>)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">"Trace"</span>)</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">"$</span><span class="ch">\\</span><span class="st">Lambda(</span><span class="ch">\\</span><span class="st">beta)$ function"</span>)</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">3</span>, <span class="dv">0</span>].set_ylabel(<span class="st">"After opt."</span>)</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, smp, title <span class="kw">in</span> <span class="bu">zip</span>(axs[<span class="dv">0</span>, :], [samples, new_samples], [<span class="st">"Initial schedule"</span>, <span class="st">"New schedule"</span>]):</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>  ax.hist(_sample_true, histtype<span class="op">=</span><span class="st">"step"</span>, color<span class="op">=</span><span class="st">"w"</span>, bins<span class="op">=</span>_BINS, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>  ax.hist(smp[..., <span class="op">-</span><span class="dv">1</span>], bins<span class="op">=</span>_BINS, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>  ax.spines[[<span class="st">"top"</span>, <span class="st">"left"</span>, <span class="st">"right"</span>]].set_visible(<span class="va">False</span>)</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>  ax.set_yticks([])</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>  ax.set_title(title)</span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, smp <span class="kw">in</span> <span class="bu">zip</span>(axs[<span class="dv">1</span>, :], [samples, new_samples]):</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>  ax.plot(smp[..., <span class="op">-</span><span class="dv">1</span>], color<span class="op">=</span><span class="st">"C3"</span>)</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>  ax.spines[[<span class="st">"top"</span>, <span class="st">"right"</span>]].set_visible(<span class="va">False</span>)</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>  ax.set_xlabel(<span class="st">"Time"</span>)</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, fn <span class="kw">in</span> <span class="bu">zip</span>(axs[<span class="dv">2</span>, :], [_lambda_fn, _new_lambda_fn]):</span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>  x_ax <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">30</span>)</span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>  ax.plot(x_ax, fn(x_ax), c<span class="op">=</span><span class="st">"w"</span>)</span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>  ax.spines[[<span class="st">"top"</span>, <span class="st">"right"</span>]].set_visible(<span class="va">False</span>)</span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>  ax.set_xlabel(<span class="st">"$</span><span class="ch">\\</span><span class="st">beta$"</span>)</span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, [x_sch, y_sch] <span class="kw">in</span> <span class="bu">zip</span>(</span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">3</span>, :],</span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>  [</span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>    [initial_schedule, new_schedule],</span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a>    [new_schedule, very_new_schedule],</span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a>  ax.set_xlabel(<span class="st">"Schedule before opt."</span>)</span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a>  ax.spines[[<span class="st">"top"</span>, <span class="st">"right"</span>]].set_visible(<span class="va">False</span>)</span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a>  ax.scatter(</span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>    x_sch,</span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a>    y_sch,</span>
<span id="cb43-45"><a href="#cb43-45" aria-hidden="true" tabindex="-1"></a>    c<span class="op">=</span><span class="st">"C1"</span>,</span>
<span id="cb43-46"><a href="#cb43-46" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">3</span><span class="op">**</span><span class="dv">2</span>,</span>
<span id="cb43-47"><a href="#cb43-47" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb43-48"><a href="#cb43-48" aria-hidden="true" tabindex="-1"></a>  ax.plot(x_sch, x_sch, linestyle<span class="op">=</span><span class="st">":"</span>, c<span class="op">=</span><span class="st">"w"</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb43-49"><a href="#cb43-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-50"><a href="#cb43-50" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="non-reversible-parallel-tempering_files/figure-html/cell-36-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>This looks pretty good to me! We see that the mixing has improved and the sample is of better quality. The <span class="math inline">\(\Lambda(\beta)\)</span> differs a bit (resulting in a refined optimised schedule), but I would argue that this disagreement is reasonable. It also nice to see that the third schedule is close to the second one. In the paper, it is suggested to run the optimisation multiple times and the authors propose solutions how to allocate the computational budget within the preliminary runs and the last sampling phase.</p>
</section>
</section>
<section id="summary-1" class="level3">
<h3 class="anchored" data-anchor-id="summary-1">Summary</h3>
<p>I am very excited about parallel tempering! Some related thoughts:</p>
<ul>
<li>Can we design other update schemes than DEO, which round-trip rate could be improved <span class="math inline">\(\Lambda\)</span>? How to calculate the round-trip rate for a “full sweep” update scheme? Could alternating “full sweep forward” and “full sweep backward” improve the performance of the algorithm, or somewhat degenerate to the diffuse behaviour?</li>
<li>DEO removing dependency on <span class="math inline">\(N\)</span> from SEO reminds me of <a href="https://en.wikipedia.org/wiki/Preconditioned_Crank%E2%80%93Nicolson_algorithm">preconditioned Crank-Nicolson algorithm</a>, which works better than the random-walk Metropolis in high dimensions. Is it possible to somewhat formalise a possible connection between these ideas?</li>
<li>How to use parallel tempering when working with Gibbs samplers? Building a bridge through tempering between prior and posterior can break the conjugacy employed at some steps. Also, Gibbs samplers do not need to explore the prior (acting as the reference distribution) effectively enough.</li>
<li>How well can the <em>data point tempering</em> work, where the data set is artificially shrunk? This could be a potential bridge for Gibbs samplers (as we can simply consider different Gibbs samplers conditioned on subsets of the data sets as the local exploration kernels), but in the context of SMC samplers, there is <a href="https://doi.org/10.1007/s11222-007-9028-9">a great 2007 paper</a> from Ajay Jasra, David Stephens and Chris Holmes, showing that (at least for SMC samplers) the data point tempering seems to work worse than the likelihood tempering.</li>
<li>Regarding the choice of the tempering scheme, <a href="https://proceedings.mlr.press/v139/syed21a.html">there is a more general likelihood tempering scheme to bridge the prior and the posterior</a>. It looks very interesting, but I have not read this paper yet.</li>
</ul>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>It is tempting to use priors <span class="math inline">\(p_0\)</span> which are easy to sample from, but for which <span class="math inline">\(\log p_0(x)\)</span> can be intractable. However, that one has to evaluate <span class="math inline">\(\log p_0(x)\)</span> to construct the Markov kernels targeting intermediate distributions <span class="math inline">\(p_n\)</span> for <span class="math inline">\(0 &lt; n &lt; N\)</span>. Only for swapping the chains we can rely just on the likelihood.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>